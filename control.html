<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Revision Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            padding: 20px;
        }

        h1 {
            font-size: 18px;
            margin-bottom: 20px;
            color: #888;
        }

        .section {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .section h2 {
            font-size: 14px;
            color: #0066FF;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        button {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #3a3a3a;
            padding: 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        button:hover {
            background: #3a3a3a;
            border-color: #4a4a4a;
        }

        button:active {
            background: #0066FF;
        }

        .status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #444;
            margin-right: 8px;
        }

        .status.connected {
            background: #00ff00;
            box-shadow: 0 0 8px #00ff00;
        }

        .status.spp {
            background: #ffcc00;
            box-shadow: 0 0 8px #ffcc00;
            animation: pulse-spp 0.3s ease-out;
        }

        @keyframes pulse-spp {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .eq-container {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            align-items: flex-end;
            height: 120px;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            padding: 10px;
        }

        .eq-bar {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            height: 100%;
        }

        .eq-bar-container {
            width: 100%;
            flex: 1;
            background: #1a1a1a;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
            margin-bottom: 25px;
        }

        /* Dark containers */
        .eq-bar-container {
            background: #0a0a0a;
        }

        /* Bar fills with gradients that stay fixed to container height */
        .eq-bar-fill {
            width: 100%;
            border-radius: 3px;
            position: absolute;
            bottom: 0;
            height: 0%;
            transition: height 0.05s ease-out;
            background-size: 100% 100px;
            background-position: bottom;
            background-repeat: no-repeat;
        }

        /* Bass - red/orange/yellow gradient */
        .eq-bar:nth-child(1) .eq-bar-fill {
            background-image: linear-gradient(to top, #660000, #FF2200, #FF6600, #FFAA00);
            box-shadow: 0 0 15px rgba(255, 102, 0, 0.8);
        }

        /* Mid - green/lime/yellow gradient */
        .eq-bar:nth-child(2) .eq-bar-fill {
            background-image: linear-gradient(to top, #003300, #00CC00, #66FF00, #CCFF00);
            box-shadow: 0 0 15px rgba(102, 255, 0, 0.8);
        }

        /* High - blue/cyan gradient */
        .eq-bar:nth-child(3) .eq-bar-fill {
            background-image: linear-gradient(to top, #002266, #0066FF, #00AAFF, #00FFFF);
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.8);
        }

        .eq-label {
            font-size: 9px;
            color: #666;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        select {
            width: 100%;
            background: #0a0a0a;
            color: #fff;
            border: 1px solid #2a2a2a;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .preset-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .preset-item {
            padding: 12px 15px;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            margin-bottom: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            user-select: none; /* Prevent text selection interfering with clicks */
            -webkit-user-select: none;
            transition: background 0.1s ease;
        }

        .preset-item:hover {
            background: #2a2a2a;
        }

        .preset-item.active {
            background: #0066FF;
            border-color: #0088FF;
        }
    </style>
</head>
<body>
    <h1>REVISION CONTROL</h1>

    <div class="section">
        <h2><span class="status" id="connection-status"></span>Connection <span class="status" id="spp-indicator" title="SPP Activity"></span></h2>
        <div class="info">Connected to main tab via BroadcastChannel</div>
        <div class="info" style="margin-top: 5px;">Mode: <span id="current-mode" style="color: #0066FF;">-</span></div>
        <div class="info" style="margin-top: 5px;">BPM: <span id="current-bpm" style="color: #0066FF;">-</span> | Position: <span id="current-position" style="color: #0066FF;">-</span></div>
        <div class="info" style="margin-top: 5px;">Audio Source: <span id="current-audio-source" style="color: #0066FF;">-</span></div>
    </div>

    <div class="section">
        <h2>Audio Information</h2>
        <div class="eq-container">
            <div class="eq-bar">
                <div class="eq-bar-container">
                    <div class="eq-bar-fill" id="bass-bar" style="height: 0%;"></div>
                </div>
                <div class="eq-label">Bass</div>
            </div>
            <div class="eq-bar">
                <div class="eq-bar-container">
                    <div class="eq-bar-fill" id="mid-bar" style="height: 0%;"></div>
                </div>
                <div class="eq-label">Mid</div>
            </div>
            <div class="eq-bar">
                <div class="eq-bar-container">
                    <div class="eq-bar-fill" id="high-bar" style="height: 0%;"></div>
                </div>
                <div class="eq-label">High</div>
            </div>
        </div>
        <div class="info">Real-time frequency analysis from active audio source</div>
    </div>

    <div class="section">
        <h2>MIDI Device <span id="midi-perm-warning" style="color: #ff6600; font-size: 11px; display: none;">⚠️ Permission required - click PERMISSIONS in main window</span></h2>
        <select id="midi-input-select">
            <option value="">No MIDI devices found</option>
        </select>
        <div class="info">MIDI input device for clock, SPP, and notes</div>

        <label style="font-size: 11px; color: #888; text-transform: uppercase; display: block; margin-top: 15px; margin-bottom: 5px;">Enable SysEx</label>
        <select id="sysex-enable">
            <option value="true">Yes (requires permission)</option>
            <option value="false">No</option>
        </select>
        <div class="info" style="margin-top: 5px;">Allow MIDI SysEx messages (requires page reload)</div>
    </div>

    <div class="section">
        <h2>Audio Input <span id="audio-perm-warning" style="color: #ff6600; font-size: 11px; display: none;">⚠️ Permission required - click PERMISSIONS in main window</span></h2>
        <select id="audio-device-select">
            <option value="none">No Audio Input</option>
        </select>
        <div class="info">Select microphone or audio input device</div>
    </div>

    <div class="section">
        <h2>Visual Reactive Input</h2>
        <select id="milkdrop-audio-source">
            <option value="microphone" selected>Audio Input Device</option>
            <option value="midi">MIDI Synthesizer</option>
        </select>

        <div id="midi-synth-options" style="margin-top: 10px;">
            <label style="font-size: 11px; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px;">MIDI Channel Filter</label>
            <select id="midi-synth-channel">
                <option value="all">All MIDI Channels</option>
                <option value="0">MIDI Channel 1</option>
                <option value="1">MIDI Channel 2</option>
                <option value="2">MIDI Channel 3</option>
                <option value="3">MIDI Channel 4</option>
                <option value="4">MIDI Channel 5</option>
                <option value="5">MIDI Channel 6</option>
                <option value="6">MIDI Channel 7</option>
                <option value="7">MIDI Channel 8</option>
                <option value="8">MIDI Channel 9</option>
                <option value="9">MIDI Channel 10 (Drums)</option>
                <option value="10">MIDI Channel 11</option>
                <option value="11">MIDI Channel 12</option>
                <option value="12">MIDI Channel 13</option>
                <option value="13">MIDI Channel 14</option>
                <option value="14">MIDI Channel 15</option>
                <option value="15">MIDI Channel 16</option>
            </select>

            <label style="display: block; margin-top: 10px; font-size: 12px;">
                <input type="checkbox" id="midi-synth-audible" style="width: auto; margin-right: 5px;">
                Make MIDI synth audible (hear the notes)
            </label>
        </div>

        <div class="info">Audio source for ALL visual renderers (Three.js, Milkdrop, Waveform)</div>
    </div>

    <div class="section">
        <h2>PROGRAM Output</h2>
        <div class="info">Mode: <span id="current-mode-display" style="color: #0066FF; font-weight: bold;">-</span></div>
        <div class="info" id="program-scene-display" style="margin-top: 5px; display: none;">Scene: <span id="program-scene-name" style="color: #0066FF; font-weight: bold;">-</span></div>
        <div class="info" style="margin-top: 5px; color: #888;">Select options below and click GO TO PROGRAM to update main display</div>
    </div>

    <div class="section" id="builtin-section">
        <h2>Built-in Scenes (Preview)</h2>

        <!-- Program status -->
        <div class="info" id="program-builtin-display" style="margin-bottom: 10px; display: none;">Program: <span id="program-builtin-name" style="color: #00ff00; font-weight: bold;">-</span></div>

        <!-- Renderer Selection -->
        <div class="info" id="program-renderer-display" style="margin-bottom: 10px; display: none;">Program Renderer: <span id="program-renderer-name" style="color: #00ff00; font-weight: bold;">-</span></div>

        <label style="font-size: 11px; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px;">Staged Renderer Mode</label>
        <select id="renderer-select" style="width: 100%; margin-bottom: 15px;">
            <option value="webgl">WebGL (Recommended)</option>
            <option value="canvas2d">Canvas 2D</option>
        </select>

        <!-- Preview Canvas -->
        <div id="builtin-preview-container" style="margin-bottom: 15px; display: none;">
            <div style="position: relative; background: #000; border: 2px solid #0066FF; border-radius: 4px; overflow: hidden;">
                <canvas id="builtin-preview-canvas" style="width: 100%; height: auto; display: block;"></canvas>
                <div style="position: absolute; top: 5px; left: 5px; background: rgba(0,102,255,0.8); color: white; padding: 3px 8px; border-radius: 3px; font-size: 10px; font-weight: bold;">PREVIEW</div>
            </div>
        </div>

        <div class="info" style="margin-bottom: 5px;">Staged: <span id="staged-builtin-name" style="color: #0066FF; font-weight: bold;">-</span></div>

        <div class="button-grid">
            <button onclick="previewBuiltinScene(0)" id="scene-0">Scene 1<br><small>Tunnel</small></button>
            <button onclick="previewBuiltinScene(1)" id="scene-1">Scene 2<br><small>Particles</small></button>
            <button onclick="previewBuiltinScene(2)" id="scene-2">Scene 3<br><small>Kaleidoscope</small></button>
            <button onclick="previewBuiltinScene(3)" id="scene-3">Scene 4<br><small>Waveform</small></button>
        </div>
        <button onclick="goToProgramBuiltin()" style="width: 100%; padding: 12px; margin-top: 10px; background: #00aa00; border-color: #00cc00; font-weight: bold;">▶ GO TO PROGRAM (Built-in)</button>
    </div>

    <div class="section" id="milkdrop-section">
        <h2>Milkdrop Presets (Preview)</h2>

        <!-- Program status -->
        <div class="info" id="program-preset-display" style="margin-bottom: 10px; display: none;">Program: <span id="program-preset-name" style="color: #00ff00; font-weight: bold;">-</span></div>

        <!-- Preview Canvas -->
        <div id="milkdrop-preview-container" style="margin-bottom: 15px; display: none;">
            <div style="position: relative; background: #000; border: 2px solid #0066FF; border-radius: 4px; overflow: hidden;">
                <canvas id="milkdrop-preview-canvas" style="width: 100%; height: auto; display: block;"></canvas>
                <div style="position: absolute; top: 5px; left: 5px; background: rgba(0,102,255,0.8); color: white; padding: 3px 8px; border-radius: 3px; font-size: 10px; font-weight: bold;">PREVIEW</div>
            </div>
        </div>

        <div class="button-grid">
            <button onclick="stageMilkdropNav('prev')">◀ Previous</button>
            <button onclick="stageMilkdropNav('next')">Next ▶</button>
        </div>
        <div class="info">Staged: <span id="staged-preset" style="color: #0066FF; font-weight: bold;">-</span></div>

        <div class="preset-list" id="preset-list">
            <!-- Populated dynamically -->
        </div>
        <button onclick="goToProgramMilkdrop()" style="width: 100%; padding: 12px; margin-top: 10px; background: #00aa00; border-color: #00cc00; font-weight: bold;">▶ GO TO PROGRAM (Milkdrop)</button>
    </div>

    <div class="section" id="video-section">
        <h2>Video Feed <span id="video-perm-warning" style="color: #ff6600; font-size: 11px; display: none;">⚠️ Permission required - click PERMISSIONS in main window</span></h2>
        <select id="video-device-select">
            <option value="">No camera selected</option>
        </select>
        <div class="info">Select camera to preview</div>

        <!-- Camera Preview -->
        <div id="video-preview-container" style="margin-top: 15px; display: none;">
            <div style="position: relative; background: #000; border: 2px solid #0066FF; border-radius: 4px; overflow: hidden;">
                <canvas id="video-preview-canvas" style="width: 100%; height: auto; display: block;"></canvas>
                <div style="position: absolute; top: 5px; left: 5px; background: rgba(0,102,255,0.8); color: white; padding: 3px 8px; border-radius: 3px; font-size: 10px; font-weight: bold;">PREVIEW</div>
            </div>
            <button id="video-go-program" style="width: 100%; padding: 12px; margin-top: 10px; background: #00aa00; border-color: #00cc00; font-weight: bold;">▶ GO TO PROGRAM</button>
            <button id="video-release-preview" style="width: 100%; padding: 8px; margin-top: 5px;">Release Preview</button>
        </div>

        <label style="display: block; margin-top: 15px; font-size: 12px;">
            <input type="checkbox" id="video-audio-reactive" style="width: auto; margin-right: 5px;">
            Audio-reactive color effects (hue, saturation, brightness)
        </label>

        <label style="display: block; margin-top: 10px; font-size: 12px;">
            <input type="checkbox" id="video-beat-reactive" style="width: auto; margin-right: 5px;">
            Beat-reactive zoom pulse (4-on-the-floor)
        </label>

        <div style="margin-top: 15px;">
            <button onclick="sendCommand('videoRelease')" style="width: 100%; padding: 10px;">Release Program Camera</button>
            <div class="info" style="margin-top: 5px;">Release camera on main display</div>
        </div>
    </div>

    <div class="section">
        <h2>OSC Server (Optional)</h2>
        <input type="text" id="osc-server" placeholder="ws://localhost:8080" style="width: 100%; background: #0a0a0a; color: #fff; border: 1px solid #2a2a2a; padding: 10px; border-radius: 4px;" />
        <div class="info">WebSocket OSC server for external control</div>
    </div>

    <!-- Butterchurn for Milkdrop preview -->
    <script src="https://unpkg.com/butterchurn@latest/lib/butterchurn.min.js"></script>
    <script src="https://unpkg.com/butterchurn-presets@latest/lib/butterchurnPresets.min.js"></script>

    <!-- Renderers for preview -->
    <script src="renderers/video-renderer.js"></script>
    <script src="visuals/renderer.js"></script>
    <script src="scenes/scene-manager.js"></script>

    <script>
        // BroadcastChannel for tab-to-tab communication
        const controlChannel = new BroadcastChannel('revision-control');

        // Video preview
        let videoPreviewRenderer = null;
        let currentPreviewDeviceId = null;

        // Effect previews
        let builtinPreviewRenderer = null;
        let builtinSceneManager = null;
        let milkdropPreviewVisualizer = null;
        let milkdropPreviewAudioContext = null;

        // Current program state (synced from main app)
        let currentProgramMode = 'builtin';
        let currentProgramRenderer = 'webgl';
        let currentProgramScene = 0;

        // Staged renderer mode (for preview, not synced after init)
        let currentRendererMode = 'webgl';

        // Staged state (preview before sending to program)
        let stagedBuiltinScene = 0;
        let stagedMilkdropIndex = 0;
        let milkdropPresetList = [];

        // GO TO PROGRAM functions
        function goToProgramBuiltin() {
            console.log('[Control] GO TO PROGRAM: Built-in Scene', stagedBuiltinScene, 'Renderer:', currentRendererMode);
            console.log('[Control] Current program state - Mode:', currentProgramMode, 'Scene:', currentProgramScene, 'Renderer:', currentProgramRenderer);

            // If already in builtin mode, just switch scene and renderer
            if (currentProgramMode === 'builtin') {
                console.log('[Control] Already in builtin mode - switching scene and renderer simultaneously');

                // Send both commands at the same time (no delay)
                sendCommand('switchScene', stagedBuiltinScene);
                sendCommand('rendererSelect', currentRendererMode);
            } else {
                // Not in builtin mode - need to switch mode first
                console.log('[Control] Switching to builtin mode');
                sendCommand('switchMode', 'builtin');

                // Then switch scene AND renderer simultaneously (wait for mode to activate)
                setTimeout(() => {
                    sendCommand('switchScene', stagedBuiltinScene);
                    sendCommand('rendererSelect', currentRendererMode);
                }, 100);
            }
        }

        function goToProgramMilkdrop() {
            console.log('[Control] GO TO PROGRAM: Milkdrop Preset', stagedMilkdropIndex);
            sendCommand('switchMode', 'milkdrop');
            setTimeout(() => {
                sendCommand('milkdropSelect', stagedMilkdropIndex);
            }, 100);
        }

        function stageMilkdropNav(direction) {
            if (direction === 'next') {
                stagedMilkdropIndex = (stagedMilkdropIndex + 1) % milkdropPresetList.length;
            } else {
                stagedMilkdropIndex--;
                if (stagedMilkdropIndex < 0) stagedMilkdropIndex = milkdropPresetList.length - 1;
            }
            // Preview the new preset
            previewMilkdropPreset(stagedMilkdropIndex);
        }

        function updateStagedPresetDisplay() {
            const display = document.getElementById('staged-preset');
            if (milkdropPresetList.length > 0) {
                display.textContent = milkdropPresetList[stagedMilkdropIndex];
            }
        }

        // Preview Built-in Scene
        function previewBuiltinScene(sceneIndex) {
            stagedBuiltinScene = sceneIndex;

            // Update staged display
            const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
            document.getElementById('staged-builtin-name').textContent = sceneNames[sceneIndex];

            // Update button visual states
            for (let i = 0; i < 4; i++) {
                const btn = document.getElementById(`scene-${i}`);
                if (btn) {
                    if (i === sceneIndex) {
                        btn.style.background = '#0066FF';
                        btn.style.borderColor = '#0088FF';
                    } else {
                        btn.style.background = '#2a2a2a';
                        btn.style.borderColor = '#3a3a3a';
                    }
                }
            }

            // Reinitialize renderer if mode changed
            const needsReinit = builtinPreviewRenderer && builtinPreviewRenderer.mode !== currentRendererMode;
            if (needsReinit) {
                console.log('[Control] Renderer mode changed, reinitializing preview...');
                builtinPreviewRenderer.stop();
                builtinPreviewRenderer = null;
                builtinSceneManager = null;
            }

            // Initialize renderer if not exists
            if (!builtinPreviewRenderer) {
                const canvas = document.getElementById('builtin-preview-canvas');
                canvas.width = 640;
                canvas.height = 360;
                builtinPreviewRenderer = new VisualRenderer(canvas.id);
                builtinPreviewRenderer.initialize(currentRendererMode);
                builtinSceneManager = new SceneManager(builtinPreviewRenderer);
                console.log('[Control] Preview renderer initialized with mode:', currentRendererMode);
            }

            // Show preview container
            document.getElementById('builtin-preview-container').style.display = 'block';

            // Switch scene
            builtinSceneManager.switchScene(sceneIndex);
            builtinPreviewRenderer.start();

            console.log('[Control] Previewing Built-in Scene', sceneIndex, 'with renderer:', currentRendererMode);
        }

        // Preview Milkdrop Preset
        function previewMilkdropPreset(index) {
            try {
                if (!milkdropPresetList || milkdropPresetList.length === 0) {
                    console.warn('[Control] No milkdrop preset list available');
                    return;
                }

                // Check if butterchurn is loaded
                if (typeof butterchurn === 'undefined' || typeof butterchurnPresets === 'undefined') {
                    console.error('[Control] Butterchurn library not loaded - skipping preview');
                    return;
                }

                stagedMilkdropIndex = index;
                updateStagedPresetDisplay();

                // Initialize Milkdrop if not exists
                if (!milkdropPreviewVisualizer) {
                    console.log('[Control] Creating Milkdrop preview visualizer...');
                    const canvas = document.getElementById('milkdrop-preview-canvas');
                    canvas.width = 640;
                    canvas.height = 360;

                    // Create AudioContext for butterchurn
                    milkdropPreviewAudioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Try both API variations (butterchurn vs butterchurn.default)
                    const butterchurnAPI = butterchurn.createVisualizer ? butterchurn : (butterchurn.default || butterchurn);

                    if (!butterchurnAPI.createVisualizer) {
                        console.error('[Control] Butterchurn API not available - createVisualizer not found');
                        console.log('[Control] Available butterchurn properties:', Object.keys(butterchurn));
                        return;
                    }

                    // Create butterchurn instance
                    milkdropPreviewVisualizer = butterchurnAPI.createVisualizer(milkdropPreviewAudioContext, canvas, {
                        width: 640,
                        height: 360,
                        pixelRatio: 1,
                        meshWidth: 32,
                        meshHeight: 24
                    });

                    console.log('[Control] ✓ Milkdrop preview visualizer created');
                }

                // Show preview container
                document.getElementById('milkdrop-preview-container').style.display = 'block';

                // Load preset
                const allPresets = butterchurnPresets.getPresets();
                const presetKey = milkdropPresetList[index];
                const preset = allPresets[presetKey];

                if (!preset) {
                    console.error('[Control] Preset not found:', presetKey);
                    return;
                }

                milkdropPreviewVisualizer.loadPreset(preset, 0); // 0 = no blend transition
                console.log('[Control] ✓ Previewing Milkdrop preset:', presetKey);

                // Start render loop if not already running
                if (!window.milkdropPreviewAnimating) {
                    window.milkdropPreviewAnimating = true;
                    function animateMilkdropPreview() {
                        if (milkdropPreviewVisualizer) {
                            try {
                                milkdropPreviewVisualizer.render();
                                requestAnimationFrame(animateMilkdropPreview);
                            } catch (err) {
                                console.error('[Control] Milkdrop render error:', err);
                                window.milkdropPreviewAnimating = false;
                            }
                        }
                    }
                    animateMilkdropPreview();
                }
            } catch (error) {
                console.error('[Control] Failed to preview Milkdrop preset:', error);
                console.error('[Control] Error stack:', error.stack);
                // Don't show alert - just log error to avoid blocking UI
            }
        }

        // MIDI for optional external control
        let midiAccess = null;
        let midiOutput = null;

        // Send command to main tab via BroadcastChannel
        function sendCommand(command, data) {
            const message = { command, data };
            controlChannel.postMessage(message);
            console.log('[Control] Sent:', message);
        }

        // Receive state updates from main tab
        controlChannel.onmessage = (event) => {
            const { type, data } = event.data;

            switch (type) {
                case 'stateUpdate':
                    updateState(data);
                    break;
                case 'presetList':
                    displayPresets(data);
                    break;
            }
        };

        function updateState(state) {
            // Update connection status
            document.getElementById('connection-status').classList.add('connected');

            // Update BPM and position
            if (state.bpm !== undefined) {
                document.getElementById('current-bpm').textContent = state.bpm;
            }
            if (state.position !== undefined) {
                document.getElementById('current-position').textContent = state.position;
            }

            // Update audio device selection
            if (state.audioDeviceId !== undefined) {
                const audioSelect = document.getElementById('audio-device-select');
                audioSelect.value = state.audioDeviceId;
            }

            // Update EQ bars
            if (state.frequency !== undefined) {
                const bass = Math.min(100, Math.round((state.frequency.bass || 0) * 100));
                const mid = Math.min(100, Math.round((state.frequency.mid || 0) * 100));
                const high = Math.min(100, Math.round((state.frequency.high || 0) * 100));

                document.getElementById('bass-bar').style.height = `${bass}%`;
                document.getElementById('mid-bar').style.height = `${mid}%`;
                document.getElementById('high-bar').style.height = `${high}%`;
            }

            // Update SPP indicator
            if (state.sppActive === true) {
                const sppIndicator = document.getElementById('spp-indicator');
                sppIndicator.classList.add('spp');
                // Remove after animation completes
                setTimeout(() => {
                    sppIndicator.classList.remove('spp');
                }, 300);
            }

            // Update visual audio source - ALWAYS from main app state, NEVER from saved settings
            if (state.visualAudioSource !== undefined) {
                const dropdown = document.getElementById('milkdrop-audio-source');
                dropdown.value = state.visualAudioSource;
                // Removed spam log - broadcasts every 100ms

                // Show/hide MIDI options based on source
                const midiOptions = document.getElementById('midi-synth-options');
                midiOptions.style.display = state.visualAudioSource === 'midi' ? 'block' : 'none';
            }

            // Update MIDI synth settings
            if (state.midiSynthChannel !== undefined) {
                document.getElementById('midi-synth-channel').value = state.midiSynthChannel;
            }
            if (state.midiSynthAudible !== undefined) {
                document.getElementById('midi-synth-audible').checked = state.midiSynthAudible === 'true';
            }

            // Update current mode display and track program mode
            if (state.mode) {
                currentProgramMode = state.mode; // Track current program mode
                const modeNames = { builtin: 'Built-in', threejs: 'Three.js', milkdrop: 'Milkdrop', video: 'Video' };
                document.getElementById('current-mode-display').textContent = modeNames[state.mode] || state.mode;

                // Show/hide scene display based on mode
                const sceneDisplay = document.getElementById('program-scene-display');
                if (state.mode === 'builtin' && state.scene !== undefined) {
                    currentProgramScene = state.scene; // Track current scene
                    const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
                    document.getElementById('program-scene-name').textContent = sceneNames[state.scene] || state.scene;
                    sceneDisplay.style.display = '';
                } else {
                    sceneDisplay.style.display = 'none';
                }

                // Update Built-in section program display
                const builtinProgramDisplay = document.getElementById('program-builtin-display');
                if (state.mode === 'builtin' && state.scene !== undefined) {
                    const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
                    document.getElementById('program-builtin-name').textContent = sceneNames[state.scene];
                    builtinProgramDisplay.style.display = '';
                } else {
                    builtinProgramDisplay.style.display = 'none';
                }
            }

            // DON'T sync scene buttons from program - they represent what's staged, not what's on program
            // Scene button styling is controlled by previewBuiltinScene() function

            // Update program preset name (what's on main display)
            if (state.presetName && state.mode === 'milkdrop') {
                const programPresetDisplay = document.getElementById('program-preset-display');
                const programPresetName = document.getElementById('program-preset-name');
                programPresetName.textContent = state.presetName;
                programPresetDisplay.style.display = '';
            } else {
                const programPresetDisplay = document.getElementById('program-preset-display');
                if (programPresetDisplay) {
                    programPresetDisplay.style.display = 'none';
                }
            }

            // Update audio source display
            if (state.audioSourceDisplay) {
                document.getElementById('current-audio-source').textContent = state.audioSourceDisplay;
            }

            // Update MIDI input device
            if (state.midiInputId !== undefined) {
                const midiSelect = document.getElementById('midi-input-select');
                if (midiSelect && midiSelect.querySelector(`option[value="${state.midiInputId}"]`)) {
                    midiSelect.value = state.midiInputId;
                }
            }

            // Update SysEx setting
            if (state.enableSysEx !== undefined) {
                document.getElementById('sysex-enable').value = state.enableSysEx;
            }

            // Update program renderer display (what's actually on main display)
            if (state.renderer !== undefined && state.mode === 'builtin') {
                currentProgramRenderer = state.renderer; // Track current program renderer
                const rendererNames = { webgl: 'WebGL', canvas2d: 'Canvas 2D' };
                document.getElementById('program-renderer-name').textContent = rendererNames[state.renderer] || state.renderer;
                document.getElementById('program-renderer-display').style.display = '';

                // Only initialize staged renderer dropdown once on first state update
                if (!window.rendererInitialized) {
                    currentRendererMode = state.renderer;
                    document.getElementById('renderer-select').value = state.renderer;
                    window.rendererInitialized = true;
                }
            } else {
                const rendererDisplay = document.getElementById('program-renderer-display');
                if (rendererDisplay) {
                    rendererDisplay.style.display = 'none';
                }
            }

            // Update OSC server
            if (state.oscServer !== undefined) {
                document.getElementById('osc-server').value = state.oscServer;
            }

            // Update video device selection
            if (state.videoDeviceId !== undefined) {
                const videoSelect = document.getElementById('video-device-select');
                if (videoSelect && videoSelect.querySelector(`option[value="${state.videoDeviceId}"]`)) {
                    videoSelect.value = state.videoDeviceId;
                }
            }

            // Update video audio reactive toggle
            if (state.videoAudioReactive !== undefined) {
                document.getElementById('video-audio-reactive').checked = state.videoAudioReactive === 'true';
            }

            // Update video beat reactive toggle
            if (state.videoBeatReactive !== undefined) {
                document.getElementById('video-beat-reactive').checked = state.videoBeatReactive === 'true';
            }
        }


        // Load preset list from main app (not local config)
        // This is now handled by 'requestState' which triggers 'presetList' broadcast
        async function loadPresets() {
            console.log('[Control] Preset list will be loaded from main app via BroadcastChannel');
            // No local loading - main app is source of truth
        }

        function displayPresets(presets) {
            if (!presets || presets.length === 0) {
                return;
            }

            // Store preset list for staging
            milkdropPresetList = presets;

            const list = document.getElementById('preset-list');
            list.innerHTML = '';

            presets.forEach((preset, index) => {
                const item = document.createElement('div');
                item.className = 'preset-item';
                item.textContent = `${index}: ${preset}`;
                item.dataset.index = index;
                item.dataset.preset = preset;
                list.appendChild(item);
            });

            // Update staged display
            updateStagedPresetDisplay();
        }

        // Event delegation for preset clicks - PREVIEW preset
        document.getElementById('preset-list').addEventListener('click', (e) => {
            const item = e.target.closest('.preset-item');
            if (item) {
                const index = parseInt(item.dataset.index);

                // Update active state
                document.querySelectorAll('.preset-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');

                // Preview the preset
                previewMilkdropPreset(index);
            }
        });

        // Audio device selection
        document.getElementById('audio-device-select').addEventListener('change', (e) => {
            sendCommand('audioDeviceSelect', e.target.value);
        });

        // Milkdrop audio source selection
        document.getElementById('milkdrop-audio-source').addEventListener('change', (e) => {
            const source = e.target.value;
            sendCommand('milkdropAudioSource', source);

            // Show/hide MIDI synth options
            const midiOptions = document.getElementById('midi-synth-options');
            midiOptions.style.display = source === 'midi' ? 'block' : 'none';
        });

        // MIDI synth channel
        document.getElementById('midi-synth-channel').addEventListener('change', (e) => {
            sendCommand('midiSynthChannel', e.target.value);
        });

        // MIDI synth audible toggle
        document.getElementById('midi-synth-audible').addEventListener('change', (e) => {
            sendCommand('midiSynthAudible', e.target.checked ? 'true' : 'false');
        });

        // MIDI input device selection
        document.getElementById('midi-input-select').addEventListener('change', (e) => {
            sendCommand('midiInputSelect', e.target.value);
        });

        // SysEx enable
        document.getElementById('sysex-enable').addEventListener('change', (e) => {
            sendCommand('sysexEnable', e.target.value);
        });

        // Renderer selection - STAGE ONLY (don't send to program immediately)
        document.getElementById('renderer-select').addEventListener('change', (e) => {
            const newMode = e.target.value;
            currentRendererMode = newMode;

            // Reinitialize preview if it's active
            if (builtinPreviewRenderer) {
                console.log('[Control] Renderer changed to:', newMode, '- reinitializing preview...');
                builtinPreviewRenderer.stop();
                builtinPreviewRenderer = null;
                builtinSceneManager = null;

                // Re-preview current scene with new renderer
                previewBuiltinScene(stagedBuiltinScene);
            }

            // DON'T send to main app - only send when user clicks GO TO PROGRAM
        });

        // OSC server
        document.getElementById('osc-server').addEventListener('change', (e) => {
            sendCommand('oscServer', e.target.value);
        });

        // Video device selection - show preview first
        document.getElementById('video-device-select').addEventListener('change', async (e) => {
            const deviceId = e.target.value;

            if (!deviceId) {
                // No camera selected - hide preview
                document.getElementById('video-preview-container').style.display = 'none';
                if (videoPreviewRenderer) {
                    videoPreviewRenderer.release();
                    videoPreviewRenderer = null;
                }
                currentPreviewDeviceId = null;
                return;
            }

            // CRITICAL: Fully destroy old renderer before creating new one
            if (videoPreviewRenderer) {
                console.log('[Control] Releasing previous preview renderer...');
                videoPreviewRenderer.release();
                // Wait for release to complete
                await new Promise(resolve => setTimeout(resolve, 300));
                videoPreviewRenderer = null;
            }

            // Create fresh renderer
            const canvas = document.getElementById('video-preview-canvas');
            videoPreviewRenderer = new VideoRenderer(canvas);

            // Set canvas size BEFORE initializing
            canvas.width = 640;
            canvas.height = 360;

            // Show preview with camera feed
            console.log('[Control] Loading preview for device:', deviceId);
            const success = await videoPreviewRenderer.initialize(deviceId);

            if (success) {
                currentPreviewDeviceId = deviceId;

                // Show preview container
                document.getElementById('video-preview-container').style.display = 'block';

                // Start preview render loop
                videoPreviewRenderer.start();
                console.log('[Control] ✓ Preview started');
            } else {
                console.error('[Control] ✗ Failed to load preview');
                videoPreviewRenderer = null;
                alert('Failed to load camera preview. Try clicking "Release Preview" first.');
            }
        });

        // Go to Program button - switch to video mode AND send camera to main display
        document.getElementById('video-go-program').addEventListener('click', () => {
            if (currentPreviewDeviceId) {
                console.log('[Control] Sending camera to PROGRAM:', currentPreviewDeviceId);
                // First switch to video mode
                sendCommand('switchMode', 'video');
                // Then send the camera device (wait a bit for mode switch)
                setTimeout(() => {
                    sendCommand('videoDeviceSelect', currentPreviewDeviceId);
                }, 100);
            }
        });

        // Release Preview button
        document.getElementById('video-release-preview').addEventListener('click', () => {
            if (videoPreviewRenderer) {
                videoPreviewRenderer.release();
                document.getElementById('video-preview-container').style.display = 'none';
                document.getElementById('video-device-select').value = '';
                currentPreviewDeviceId = null;
                console.log('[Control] Preview released');
            }
        });

        // Video audio reactive toggle
        document.getElementById('video-audio-reactive').addEventListener('change', (e) => {
            sendCommand('videoAudioReactive', e.target.checked ? 'true' : 'false');
        });

        // Video beat reactive toggle
        document.getElementById('video-beat-reactive').addEventListener('change', (e) => {
            sendCommand('videoBeatReactive', e.target.checked ? 'true' : 'false');
        });

        // Populate audio devices
        // NOTE: Devices need permission granted first to show proper labels
        // Permission should already be granted by index.html on load
        async function loadAudioDevices() {
            const select = document.getElementById('audio-device-select');
            const warning = document.getElementById('audio-perm-warning');
            select.innerHTML = '<option value="none">No Audio Input</option>';

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');

                // Check if we have permission (devices will have labels)
                const hasPermission = audioInputs.length > 0 && audioInputs[0].label !== '';

                if (!hasPermission && audioInputs.length > 0) {
                    // Devices exist but no labels = permission not granted
                    console.log('[Control] Audio permission not granted - device labels are empty');
                    console.log('[Control] ⚠️ Click PERMISSIONS button in index.html to grant audio access');
                    warning.style.display = 'inline';
                    return;
                }

                // Hide warning - permission granted
                warning.style.display = 'none';

                if (audioInputs.length === 0) {
                    console.log('[Control] No audio input devices found');
                    select.innerHTML = '<option value="none">No audio devices found</option>';
                    return;
                }

                // We have permission - show device names
                audioInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label;
                    select.appendChild(option);
                });

                console.log('[Control] Found', audioInputs.length, 'audio devices with labels');
            } catch (error) {
                console.error('[Control] Failed to enumerate audio devices:', error.message);
                select.innerHTML = '<option value="none">Error loading audio devices</option>';
            }
        }

        // Populate MIDI devices
        // NOTE: MIDI is OPTIONAL - browser may not support it or it may require HTTPS
        async function loadMIDIDevices() {
            const select = document.getElementById('midi-input-select');
            const warning = document.getElementById('midi-perm-warning');

            try {
                // Only request if not already available (won't trigger new prompt if granted)
                const access = await navigator.requestMIDIAccess();
                select.innerHTML = '';

                // Hide warning - MIDI is available
                warning.style.display = 'none';

                const inputs = Array.from(access.inputs.values());

                if (inputs.length === 0) {
                    select.innerHTML = '<option value="">No MIDI devices found</option>';
                    console.log('[Control] MIDI access granted but no devices connected');
                    return;
                }

                inputs.forEach(input => {
                    const option = document.createElement('option');
                    option.value = input.id;
                    option.textContent = input.name;
                    select.appendChild(option);
                });

                console.log('[Control] Found', inputs.length, 'MIDI devices');
            } catch (error) {
                // MIDI not available - this is OPTIONAL, so just hide warning and show message
                console.log('[Control] MIDI not available:', error.message);
                console.log('[Control] This is optional - browser may not support MIDI or requires HTTPS');

                // Hide warning - MIDI is optional, not required
                warning.style.display = 'none';

                select.innerHTML = '<option value="">MIDI not available (browser may not support it)</option>';
            }
        }

        // Populate video devices
        async function loadVideoDevices() {
            const select = document.getElementById('video-device-select');
            const warning = document.getElementById('video-perm-warning');
            select.innerHTML = '<option value="">No camera selected</option>';

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoInputs = devices.filter(device => device.kind === 'videoinput');

                // Check if we have permission (devices will have labels)
                const hasPermission = videoInputs.length > 0 && videoInputs[0].label !== '';

                if (!hasPermission && videoInputs.length > 0) {
                    // Devices exist but no labels = permission not granted
                    console.log('[Control] Video permission not granted - device labels are empty');
                    console.log('[Control] ⚠️ Click PERMISSIONS button in index.html to grant camera access');
                    warning.style.display = 'inline';
                    return;
                }

                // Hide warning - permission granted
                warning.style.display = 'none';

                videoInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label;
                    select.appendChild(option);
                });

                console.log('[Control] Found', videoInputs.length, 'video devices with labels');
            } catch (error) {
                console.error('[Control] Failed to enumerate video devices:', error.message);
            }
        }

        // Force dropdown to default to "microphone" on load
        // Main app will NEVER auto-start MIDI synth, so this is always correct initially
        document.getElementById('milkdrop-audio-source').value = 'microphone';
        document.getElementById('midi-synth-options').style.display = 'none';
        console.log('[Control] Defaulted to Audio Input Device');

        // CRITICAL: Force main app to microphone mode on control.html load
        // This ensures MIDI synth is never auto-started
        console.log('[Control] Forcing Visual Reactive Input to microphone...');
        sendCommand('milkdropAudioSource', 'microphone');

        // Initialize staged displays
        const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
        document.getElementById('staged-builtin-name').textContent = sceneNames[stagedBuiltinScene];

        // Initialize
        loadPresets();
        loadAudioDevices();
        loadMIDIDevices();
        loadVideoDevices();

        // Request full state after a short delay (allows commands to be processed first)
        setTimeout(() => {
            console.log('[Control] Requesting state from main app...');
            sendCommand('requestState');
        }, 200);
    </script>
</body>
</html>

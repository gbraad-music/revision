<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Revision Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            padding: 20px;
        }

        h1 {
            font-size: 18px;
            margin-bottom: 20px;
            color: #888;
        }

        .section {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .section h2 {
            font-size: 14px;
            color: #0066FF;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        button {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #3a3a3a;
            padding: 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        button:hover {
            background: #3a3a3a;
            border-color: #4a4a4a;
        }

        button:active {
            background: #0066FF;
        }

        .status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #444;
            margin-right: 8px;
        }

        .status.connected {
            background: #00ff00;
            box-shadow: 0 0 8px #00ff00;
        }

        .status.spp {
            background: #ffcc00;
            box-shadow: 0 0 8px #ffcc00;
            animation: pulse-spp 0.3s ease-out;
        }

        @keyframes pulse-spp {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .eq-container {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            align-items: flex-end;
            height: 120px;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            padding: 10px;
        }

        .eq-bar {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            height: 100%;
        }

        .eq-bar-container {
            width: 100%;
            flex: 1;
            background: #1a1a1a;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
            margin-bottom: 25px;
        }

        /* Dark containers */
        .eq-bar-container {
            background: #0a0a0a;
        }

        /* Bar fills with gradients that stay fixed to container height */
        .eq-bar-fill {
            width: 100%;
            border-radius: 3px;
            position: absolute;
            bottom: 0;
            height: 0%;
            transition: height 0.05s ease-out;
            background-size: 100% 100px;
            background-position: bottom;
            background-repeat: no-repeat;
        }

        /* Bass - red/orange/yellow gradient */
        .eq-bar:nth-child(1) .eq-bar-fill {
            background-image: linear-gradient(to top, #660000, #FF2200, #FF6600, #FFAA00);
            box-shadow: 0 0 15px rgba(255, 102, 0, 0.8);
        }

        /* Mid - green/lime/yellow gradient */
        .eq-bar:nth-child(2) .eq-bar-fill {
            background-image: linear-gradient(to top, #003300, #00CC00, #66FF00, #CCFF00);
            box-shadow: 0 0 15px rgba(102, 255, 0, 0.8);
        }

        /* High - blue/cyan gradient */
        .eq-bar:nth-child(3) .eq-bar-fill {
            background-image: linear-gradient(to top, #002266, #0066FF, #00AAFF, #00FFFF);
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.8);
        }

        .eq-label {
            font-size: 9px;
            color: #666;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        select {
            width: 100%;
            background: #0a0a0a;
            color: #fff;
            border: 1px solid #2a2a2a;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .preset-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .preset-item {
            padding: 12px 15px;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            margin-bottom: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            user-select: none; /* Prevent text selection interfering with clicks */
            -webkit-user-select: none;
            transition: background 0.1s ease;
        }

        .preset-item:hover {
            background: #2a2a2a;
        }

        .preset-item.active {
            background: #0066FF;
            border-color: #0088FF;
        }
    </style>
</head>
<body>
    <h1>REVISION CONTROL</h1>

    <div class="section">
        <h2><span class="status" id="connection-status"></span>Connection <span class="status" id="spp-indicator" title="SPP Activity"></span></h2>
        <div class="info">Connected to main tab via BroadcastChannel</div>
        <div class="info" style="margin-top: 5px;">Mode: <span id="current-mode" style="color: #0066FF;">-</span></div>
        <div class="info" style="margin-top: 5px;">BPM: <span id="current-bpm" style="color: #0066FF;">-</span> | Position: <span id="current-position" style="color: #0066FF;">-</span></div>
        <div class="info" style="margin-top: 5px;">Audio Source: <span id="current-audio-source" style="color: #0066FF;">-</span></div>
    </div>

    <div class="section">
        <h2>Audio Information</h2>
        <div class="eq-container">
            <div class="eq-bar">
                <div class="eq-bar-container">
                    <div class="eq-bar-fill" id="bass-bar" style="height: 0%;"></div>
                </div>
                <div class="eq-label">Bass</div>
            </div>
            <div class="eq-bar">
                <div class="eq-bar-container">
                    <div class="eq-bar-fill" id="mid-bar" style="height: 0%;"></div>
                </div>
                <div class="eq-label">Mid</div>
            </div>
            <div class="eq-bar">
                <div class="eq-bar-container">
                    <div class="eq-bar-fill" id="high-bar" style="height: 0%;"></div>
                </div>
                <div class="eq-label">High</div>
            </div>
        </div>
        <div class="info">Real-time frequency analysis from active audio source</div>
    </div>

    <div class="section">
        <h2>MIDI Device <span id="midi-perm-warning" style="color: #ff6600; font-size: 11px; display: none;">⚠️ Permission required - click PERMISSIONS in main window</span></h2>
        <select id="midi-input-select">
            <option value="">No MIDI devices found</option>
        </select>
        <div class="info">MIDI input device for clock, SPP, and notes</div>

        <label style="font-size: 11px; color: #888; text-transform: uppercase; display: block; margin-top: 15px; margin-bottom: 5px;">Enable SysEx</label>
        <select id="sysex-enable">
            <option value="true">Yes (requires permission)</option>
            <option value="false">No</option>
        </select>
        <div class="info" style="margin-top: 5px;">Allow MIDI SysEx messages (requires page reload)</div>
    </div>

    <div class="section">
        <h2>Audio Input <span id="audio-perm-warning" style="color: #ff6600; font-size: 11px; display: none;">⚠️ Permission required - click PERMISSIONS in main window</span></h2>
        <select id="audio-device-select">
            <option value="none">No Audio Input</option>
        </select>
        <div class="info">Select microphone or audio input device</div>
    </div>

    <div class="section">
        <h2>Visual Reactive Input</h2>
        <select id="milkdrop-audio-source">
            <option value="microphone" selected>Audio Input Device</option>
            <option value="midi">MIDI Synthesizer</option>
        </select>

        <div id="midi-synth-options" style="margin-top: 10px;">
            <label style="font-size: 11px; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px;">MIDI Channel Filter</label>
            <select id="midi-synth-channel">
                <option value="all">All MIDI Channels</option>
                <option value="0">MIDI Channel 1</option>
                <option value="1">MIDI Channel 2</option>
                <option value="2">MIDI Channel 3</option>
                <option value="3">MIDI Channel 4</option>
                <option value="4">MIDI Channel 5</option>
                <option value="5">MIDI Channel 6</option>
                <option value="6">MIDI Channel 7</option>
                <option value="7">MIDI Channel 8</option>
                <option value="8">MIDI Channel 9</option>
                <option value="9">MIDI Channel 10 (Drums)</option>
                <option value="10">MIDI Channel 11</option>
                <option value="11">MIDI Channel 12</option>
                <option value="12">MIDI Channel 13</option>
                <option value="13">MIDI Channel 14</option>
                <option value="14">MIDI Channel 15</option>
                <option value="15">MIDI Channel 16</option>
            </select>

            <label style="display: block; margin-top: 10px; font-size: 12px;">
                <input type="checkbox" id="midi-synth-audible" style="width: auto; margin-right: 5px;">
                Make MIDI synth audible (hear the notes)
            </label>
        </div>

        <div class="info">Audio source for ALL visual renderers (Three.js, Milkdrop, Waveform)</div>
    </div>

    <div class="section">
        <h2>PROGRAM Output</h2>
        <div class="info">Mode: <span id="current-mode-display" style="color: #00ff00; font-weight: bold;">-</span></div>
        <div class="info" id="program-builtin-display" style="margin-top: 5px; display: none;">Scene: <span id="program-builtin-name" style="color: #00ff00; font-weight: bold;">-</span></div>
        <div class="info" id="program-preset-display" style="margin-top: 5px; display: none;">Preset: <span id="program-preset-name" style="color: #00ff00; font-weight: bold;">-</span></div>
        <div class="info" id="program-renderer-display" style="margin-top: 5px; display: none;">Renderer: <span id="program-renderer-name" style="color: #00ff00; font-weight: bold;">-</span></div>
    </div>

    <div class="section">
        <h2>PREVIEW / Program</h2>

        <!-- Mode Selector Tabs -->
        <div style="display: flex; gap: 5px; margin-bottom: 15px;">
            <button onclick="switchPreviewMode('builtin')" id="preview-tab-builtin" style="flex: 1; padding: 10px; background: #0066FF; border: 1px solid #0088FF; border-radius: 4px; color: white; font-weight: bold; cursor: pointer;">Built-in</button>
            <button onclick="switchPreviewMode('milkdrop')" id="preview-tab-milkdrop" style="flex: 1; padding: 10px; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 4px; color: #888; font-weight: bold; cursor: pointer;">Milkdrop</button>
            <button onclick="switchPreviewMode('video')" id="preview-tab-video" style="flex: 1; padding: 10px; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 4px; color: #888; font-weight: bold; cursor: pointer;">Video</button>
        </div>

        <!-- Single Unified Preview Canvas -->
        <div id="unified-preview-container" style="margin-bottom: 15px;">
            <div style="position: relative; background: #000; border: 2px solid #0066FF; border-radius: 4px; overflow: hidden; width: 100%; padding-bottom: 56.25%; /* 16:9 aspect ratio */">
                <canvas id="unified-preview-canvas" width="640" height="360" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block;"></canvas>
                <div style="position: absolute; top: 5px; left: 5px; background: rgba(0,102,255,0.8); color: white; padding: 3px 8px; border-radius: 3px; font-size: 10px; font-weight: bold; z-index: 10;">PREVIEW</div>
                <div id="preview-mode-label" style="position: absolute; top: 5px; right: 5px; background: rgba(0,102,255,0.8); color: white; padding: 3px 8px; border-radius: 3px; font-size: 10px; font-weight: bold; z-index: 10;">BUILT-IN</div>
            </div>
        </div>

        <div class="info" id="staged-info" style="margin-bottom: 10px;">Staged: <span id="staged-name" style="color: #0066FF; font-weight: bold;">1 - Tunnel</span></div>

        <!-- Single GO TO PROGRAM Button -->
        <button onclick="goToProgram()" style="width: 100%; padding: 15px; background: #00aa00; border: 2px solid #00cc00; border-radius: 4px; color: white; font-weight: bold; font-size: 14px; cursor: pointer;">▶ GO TO PROGRAM</button>
    </div>

    <!-- Built-in Scene Controls -->
    <div class="section" id="builtin-controls" style="display: block;">
        <h2>Built-in Scenes</h2>

        <label style="font-size: 11px; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px;">Renderer Mode</label>
        <select id="renderer-select" style="width: 100%; margin-bottom: 15px;">
            <option value="webgl">WebGL (Recommended)</option>
            <option value="canvas2d">Canvas 2D</option>
        </select>

        <div class="button-grid">
            <button onclick="previewBuiltinScene(0)" id="scene-0">Scene 1<br><small>Tunnel</small></button>
            <button onclick="previewBuiltinScene(1)" id="scene-1">Scene 2<br><small>Particles</small></button>
            <button onclick="previewBuiltinScene(2)" id="scene-2">Scene 3<br><small>Kaleidoscope</small></button>
            <button onclick="previewBuiltinScene(3)" id="scene-3">Scene 4<br><small>Waveform</small></button>
        </div>
    </div>

    <!-- Milkdrop Preset Controls -->
    <div class="section" id="milkdrop-controls" style="display: none;">
        <h2>Milkdrop Presets</h2>

        <div class="button-grid">
            <button onclick="stageMilkdropNav('prev')">◀ Previous</button>
            <button onclick="stageMilkdropNav('next')">Next ▶</button>
        </div>

        <div class="preset-list" id="preset-list">
            <!-- Populated dynamically -->
        </div>
    </div>

    <!-- Video Camera Controls -->
    <div class="section" id="video-controls" style="display: none;">
        <h2>Video Feed <span id="video-perm-warning" style="color: #ff6600; font-size: 11px; display: none;">⚠️ Permission required - click PERMISSIONS in main window</span></h2>

        <select id="video-device-select">
            <option value="">No camera selected</option>
        </select>
        <div class="info" style="margin-top: 5px;">Select camera for preview</div>

        <label style="display: block; margin-top: 15px; font-size: 12px;">
            <input type="checkbox" id="video-audio-reactive" style="width: auto; margin-right: 5px;">
            Audio-reactive color effects (hue, saturation, brightness)
        </label>

        <label style="display: block; margin-top: 10px; font-size: 12px;">
            <input type="checkbox" id="video-beat-reactive" style="width: auto; margin-right: 5px;">
            Beat-reactive zoom pulse (4-on-the-floor)
        </label>

        <div style="margin-top: 15px;">
            <button onclick="sendCommand('videoRelease')" style="width: 100%; padding: 10px;">Release Program Camera</button>
            <div class="info" style="margin-top: 5px;">Release camera on main display</div>
        </div>
    </div>

    <div class="section">
        <h2>OSC Server (Optional)</h2>
        <input type="text" id="osc-server" placeholder="ws://localhost:8080" style="width: 100%; background: #0a0a0a; color: #fff; border: 1px solid #2a2a2a; padding: 10px; border-radius: 4px;" />
        <div class="info">WebSocket OSC server for external control</div>
    </div>

    <!-- Butterchurn for Milkdrop preview -->
    <script src="https://unpkg.com/butterchurn@latest/lib/butterchurn.min.js"></script>
    <script src="https://unpkg.com/butterchurn-presets@latest/lib/butterchurnPresets.min.js"></script>

    <!-- Renderers for preview -->
    <script src="renderers/video-renderer.js"></script>
    <script src="visuals/renderer.js"></script>
    <script src="scenes/scene-manager.js"></script>

    <script>
        // BroadcastChannel for tab-to-tab communication
        const controlChannel = new BroadcastChannel('revision-control');

        // UNIFIED PREVIEW SYSTEM - Single canvas, one renderer at a time
        let currentPreviewMode = 'builtin'; // Which tab is active: builtin/milkdrop/video
        let unifiedCanvas = null;
        let unifiedPreviewRenderer = null; // VideoRenderer OR VisualRenderer
        let unifiedSceneManager = null; // For built-in scenes
        let unifiedMilkdropVisualizer = null; // For Milkdrop
        let unifiedAudioContext = null;
        let currentVideoDeviceId = null;

        // Current program state (synced from main app)
        let currentProgramMode = 'builtin';
        let currentProgramRenderer = 'webgl';
        let currentProgramScene = 0;

        // Staged renderer mode (for preview, not synced after init)
        let currentRendererMode = 'webgl';

        // Staged state (preview before sending to program)
        let stagedBuiltinScene = 0;
        let stagedMilkdropIndex = 0;
        let stagedVideoDeviceId = '';
        let milkdropPresetList = [];

        // UNIFIED GO TO PROGRAM - Single button for all modes
        function goToProgram() {
            console.log('[Control] GO TO PROGRAM - Preview Mode:', currentPreviewMode);

            switch (currentPreviewMode) {
                case 'builtin':
                    goToProgramBuiltin();
                    break;
                case 'milkdrop':
                    goToProgramMilkdrop();
                    break;
                case 'video':
                    goToProgramVideo();
                    break;
            }
        }

        function goToProgramBuiltin() {
            console.log('[Control] GO TO PROGRAM: Built-in Scene', stagedBuiltinScene, 'Renderer:', currentRendererMode);

            if (currentProgramMode === 'builtin') {
                // Already in builtin - just switch scene and renderer simultaneously
                sendCommand('switchScene', stagedBuiltinScene);
                sendCommand('rendererSelect', currentRendererMode);
            } else {
                // Switch to builtin mode first
                sendCommand('switchMode', 'builtin');
                setTimeout(() => {
                    sendCommand('switchScene', stagedBuiltinScene);
                    sendCommand('rendererSelect', currentRendererMode);
                }, 100);
            }
        }

        function goToProgramMilkdrop() {
            console.log('[Control] GO TO PROGRAM: Milkdrop Preset', stagedMilkdropIndex);
            sendCommand('switchMode', 'milkdrop');
            setTimeout(() => {
                sendCommand('milkdropSelect', stagedMilkdropIndex);
            }, 100);
        }

        function goToProgramVideo() {
            console.log('[Control] GO TO PROGRAM: Video Camera', stagedVideoDeviceId);
            if (stagedVideoDeviceId) {
                sendCommand('switchMode', 'video');
                setTimeout(() => {
                    sendCommand('videoDeviceSelect', stagedVideoDeviceId);
                }, 100);
            } else {
                console.warn('[Control] No camera selected');
            }
        }

        // SWITCH PREVIEW MODE - Tabs for Built-in/Milkdrop/Video
        function switchPreviewMode(mode) {
            console.log('[Control] Switching preview mode to:', mode);
            currentPreviewMode = mode;

            // Update tab button styles
            document.getElementById('preview-tab-builtin').style.background = mode === 'builtin' ? '#0066FF' : '#2a2a2a';
            document.getElementById('preview-tab-builtin').style.borderColor = mode === 'builtin' ? '#0088FF' : '#3a3a3a';
            document.getElementById('preview-tab-builtin').style.color = mode === 'builtin' ? 'white' : '#888';

            document.getElementById('preview-tab-milkdrop').style.background = mode === 'milkdrop' ? '#0066FF' : '#2a2a2a';
            document.getElementById('preview-tab-milkdrop').style.borderColor = mode === 'milkdrop' ? '#0088FF' : '#3a3a3a';
            document.getElementById('preview-tab-milkdrop').style.color = mode === 'milkdrop' ? 'white' : '#888';

            document.getElementById('preview-tab-video').style.background = mode === 'video' ? '#0066FF' : '#2a2a2a';
            document.getElementById('preview-tab-video').style.borderColor = mode === 'video' ? '#0088FF' : '#3a3a3a';
            document.getElementById('preview-tab-video').style.color = mode === 'video' ? 'white' : '#888';

            // Show/hide control sections
            document.getElementById('builtin-controls').style.display = mode === 'builtin' ? 'block' : 'none';
            document.getElementById('milkdrop-controls').style.display = mode === 'milkdrop' ? 'block' : 'none';
            document.getElementById('video-controls').style.display = mode === 'video' ? 'block' : 'none';

            // Update preview mode label
            const labels = { builtin: 'BUILT-IN', milkdrop: 'MILKDROP', video: 'VIDEO' };
            document.getElementById('preview-mode-label').textContent = labels[mode];

            // Stop and cleanup old preview renderer
            cleanupPreview();

            // Start appropriate preview
            switch (mode) {
                case 'builtin':
                    initBuiltinPreview();
                    break;
                case 'milkdrop':
                    initMilkdropPreview();
                    break;
                case 'video':
                    initVideoPreview();
                    break;
            }
        }

        // CLEANUP PREVIEW - Stop current preview renderer
        function cleanupPreview() {
            console.log('[Control] Cleaning up preview renderer');

            // Stop video renderer
            if (unifiedPreviewRenderer && unifiedPreviewRenderer.release) {
                unifiedPreviewRenderer.release();
                unifiedPreviewRenderer = null;
            }

            // Stop built-in renderer
            if (unifiedPreviewRenderer && unifiedPreviewRenderer.stop) {
                unifiedPreviewRenderer.stop();
                unifiedPreviewRenderer = null;
            }

            // Stop Milkdrop visualizer
            if (unifiedMilkdropVisualizer) {
                window.milkdropPreviewAnimating = false;
                unifiedMilkdropVisualizer = null;
            }

            unifiedSceneManager = null;
        }

        // INIT BUILT-IN PREVIEW
        function initBuiltinPreview() {
            console.log('[Control] Initializing built-in preview...');

            // Replace canvas if it was used for 2D rendering (from video mode)
            const oldCanvas = document.getElementById('unified-preview-canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'unified-preview-canvas';
            newCanvas.width = oldCanvas.clientWidth;
            newCanvas.height = oldCanvas.clientHeight;
            newCanvas.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block;';

            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            unifiedCanvas = newCanvas;
            console.log('[Control] Canvas refreshed for built-in mode');

            // Create renderer if not exists or mode changed
            if (!unifiedPreviewRenderer || unifiedPreviewRenderer.mode !== currentRendererMode) {
                if (unifiedPreviewRenderer) {
                    unifiedPreviewRenderer.stop();
                }
                unifiedPreviewRenderer = new VisualRenderer('unified-preview-canvas');
                unifiedPreviewRenderer.initialize(currentRendererMode);
                unifiedSceneManager = new SceneManager(unifiedPreviewRenderer);
                console.log('[Control] ✓ Built-in renderer initialized with mode:', currentRendererMode);
            }

            // Load current staged scene
            unifiedSceneManager.switchScene(stagedBuiltinScene);
            unifiedPreviewRenderer.start();

            // Update staged name
            const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
            document.getElementById('staged-name').textContent = sceneNames[stagedBuiltinScene];
        }

        // INIT MILKDROP PREVIEW
        function initMilkdropPreview() {
            console.log('[Control] Initializing Milkdrop preview...');

            if (typeof butterchurn === 'undefined' || typeof butterchurnPresets === 'undefined') {
                console.error('[Control] Butterchurn library not loaded');
                document.getElementById('staged-name').textContent = 'Butterchurn not loaded';
                return;
            }

            // Replace canvas to ensure fresh WebGL context
            const oldCanvas = document.getElementById('unified-preview-canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'unified-preview-canvas';
            newCanvas.width = oldCanvas.clientWidth;
            newCanvas.height = oldCanvas.clientHeight;
            newCanvas.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block;';

            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            unifiedCanvas = newCanvas;
            console.log('[Control] Canvas refreshed for Milkdrop mode');

            const displayWidth = unifiedCanvas.width;
            const displayHeight = unifiedCanvas.height;
            console.log('[Control] Milkdrop canvas size:', displayWidth, 'x', displayHeight);

            if (!unifiedMilkdropVisualizer) {
                // Create AudioContext if needed
                if (!unifiedAudioContext) {
                    unifiedAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                const butterchurnAPI = butterchurn.createVisualizer ? butterchurn : (butterchurn.default || butterchurn);
                if (!butterchurnAPI.createVisualizer) {
                    console.error('[Control] Butterchurn API not available');
                    return;
                }

                // Create visualizer with actual canvas size
                unifiedMilkdropVisualizer = butterchurnAPI.createVisualizer(unifiedAudioContext, unifiedCanvas, {
                    width: displayWidth,
                    height: displayHeight,
                    pixelRatio: window.devicePixelRatio || 1,
                    meshWidth: 32,
                    meshHeight: 24
                });
                console.log('[Control] ✓ Milkdrop visualizer created at', displayWidth, 'x', displayHeight);
            }

            // Load current preset
            if (milkdropPresetList.length > 0) {
                const allPresets = butterchurnPresets.getPresets();
                const presetKey = milkdropPresetList[stagedMilkdropIndex];
                const preset = allPresets[presetKey];

                if (preset) {
                    unifiedMilkdropVisualizer.loadPreset(preset, 0);
                    document.getElementById('staged-name').textContent = presetKey;
                    console.log('[Control] ✓ Loaded preset:', presetKey);
                }
            } else {
                document.getElementById('staged-name').textContent = 'No presets available';
            }

            // Start render loop
            if (!window.milkdropPreviewAnimating) {
                window.milkdropPreviewAnimating = true;
                function animateMilkdropPreview() {
                    if (unifiedMilkdropVisualizer && window.milkdropPreviewAnimating) {
                        try {
                            unifiedMilkdropVisualizer.render();
                            requestAnimationFrame(animateMilkdropPreview);
                        } catch (err) {
                            console.error('[Control] Milkdrop render error:', err);
                            window.milkdropPreviewAnimating = false;
                        }
                    }
                }
                animateMilkdropPreview();
            }
        }

        // INIT VIDEO PREVIEW
        async function initVideoPreview() {
            console.log('[Control] Initializing video preview...');
            console.log('[Control] Staged device ID:', stagedVideoDeviceId);

            // CRITICAL: Get a fresh canvas element by replacing it
            // This is needed because we can't mix WebGL and 2D contexts
            const container = document.getElementById('unified-preview-container').querySelector('div');
            const oldCanvas = document.getElementById('unified-preview-canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'unified-preview-canvas';
            newCanvas.width = oldCanvas.clientWidth;
            newCanvas.height = oldCanvas.clientHeight;
            newCanvas.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block;';

            // Replace old canvas with new one
            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            unifiedCanvas = newCanvas;
            console.log('[Control] Canvas replaced for video mode');

            // If there's a staged camera, load it
            if (stagedVideoDeviceId) {
                try {
                    console.log('[Control] Creating VideoRenderer for canvas:', unifiedCanvas.id);
                    // Create fresh video renderer
                    unifiedPreviewRenderer = new VideoRenderer(unifiedCanvas);
                    console.log('[Control] VideoRenderer created, initializing with device:', stagedVideoDeviceId);

                    const success = await unifiedPreviewRenderer.initialize(stagedVideoDeviceId);
                    console.log('[Control] VideoRenderer initialize result:', success);

                    if (success) {
                        console.log('[Control] Starting video renderer...');
                        unifiedPreviewRenderer.start();
                        console.log('[Control] ✓ Video preview started');

                        // Get device name for display
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        const device = devices.find(d => d.deviceId === stagedVideoDeviceId);
                        const deviceName = device ? device.label : stagedVideoDeviceId.substring(0, 20) + '...';
                        document.getElementById('staged-name').textContent = 'Camera: ' + deviceName;
                    } else {
                        console.error('[Control] ✗ Failed to initialize video preview');
                        document.getElementById('staged-name').textContent = 'Failed to load camera';

                        // Show error message on canvas
                        const ctx = unifiedCanvas.getContext('2d');
                        if (ctx) {
                            ctx.fillStyle = '#000';
                            ctx.fillRect(0, 0, unifiedCanvas.width, unifiedCanvas.height);
                            ctx.fillStyle = '#ff0000';
                            ctx.font = '14px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText('Camera failed to load', unifiedCanvas.width / 2, unifiedCanvas.height / 2 - 10);
                            ctx.fillStyle = '#888';
                            ctx.font = '12px sans-serif';
                            ctx.fillText('Check permissions or try another camera', unifiedCanvas.width / 2, unifiedCanvas.height / 2 + 10);
                        }
                    }
                } catch (error) {
                    console.error('[Control] Exception initializing video preview:', error);
                    console.error('[Control] Error stack:', error.stack);
                    document.getElementById('staged-name').textContent = 'Error: ' + error.message;
                }
            } else {
                // Clear canvas and show message
                console.log('[Control] No camera selected, showing placeholder');
                const ctx = unifiedCanvas.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, unifiedCanvas.width, unifiedCanvas.height);
                    ctx.fillStyle = '#888';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Select a camera below', unifiedCanvas.width / 2, unifiedCanvas.height / 2);
                }
                document.getElementById('staged-name').textContent = 'No camera selected';
            }
        }

        // MILKDROP NAVIGATION
        function stageMilkdropNav(direction) {
            if (direction === 'next') {
                stagedMilkdropIndex = (stagedMilkdropIndex + 1) % milkdropPresetList.length;
            } else {
                stagedMilkdropIndex--;
                if (stagedMilkdropIndex < 0) stagedMilkdropIndex = milkdropPresetList.length - 1;
            }

            // Reload preview with new preset
            if (currentPreviewMode === 'milkdrop' && unifiedMilkdropVisualizer) {
                const allPresets = butterchurnPresets.getPresets();
                const presetKey = milkdropPresetList[stagedMilkdropIndex];
                const preset = allPresets[presetKey];

                if (preset) {
                    unifiedMilkdropVisualizer.loadPreset(preset, 0);
                    document.getElementById('staged-name').textContent = presetKey;
                    console.log('[Control] ✓ Loaded preset:', presetKey);
                }
            }
        }

        // BUILT-IN SCENE PREVIEW
        function previewBuiltinScene(sceneIndex) {
            stagedBuiltinScene = sceneIndex;

            // Update button visual states
            for (let i = 0; i < 4; i++) {
                const btn = document.getElementById(`scene-${i}`);
                if (btn) {
                    if (i === sceneIndex) {
                        btn.style.background = '#0066FF';
                        btn.style.borderColor = '#0088FF';
                    } else {
                        btn.style.background = '#2a2a2a';
                        btn.style.borderColor = '#3a3a3a';
                    }
                }
            }

            // If currently in builtin preview mode, update the preview immediately
            if (currentPreviewMode === 'builtin') {
                // Reinitialize if renderer mode changed
                const needsReinit = unifiedPreviewRenderer && unifiedPreviewRenderer.mode !== currentRendererMode;
                if (needsReinit) {
                    console.log('[Control] Renderer mode changed, reinitializing...');
                    unifiedPreviewRenderer.stop();
                    unifiedPreviewRenderer = new VisualRenderer('unified-preview-canvas');
                    unifiedPreviewRenderer.initialize(currentRendererMode);
                    unifiedSceneManager = new SceneManager(unifiedPreviewRenderer);
                }

                // Switch scene and update display
                if (unifiedSceneManager) {
                    unifiedSceneManager.switchScene(sceneIndex);
                    const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
                    document.getElementById('staged-name').textContent = sceneNames[sceneIndex];

                    // CRITICAL: Make sure renderer is running after scene switch
                    if (!unifiedPreviewRenderer.isRunning) {
                        unifiedPreviewRenderer.start();
                    }

                    console.log('[Control] ✓ Previewing scene:', sceneNames[sceneIndex]);
                }
            } else {
                // Just update the staged value, will load when user switches to builtin tab
                const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
                console.log('[Control] Staged scene:', sceneNames[sceneIndex]);
            }
        }

        // OLD MILKDROP PREVIEW FUNCTION - REPLACED BY UNIFIED SYSTEM
        function previewMilkdropPreset(index) {
            try {
                if (!milkdropPresetList || milkdropPresetList.length === 0) {
                    console.warn('[Control] No milkdrop preset list available');
                    return;
                }

                // Check if butterchurn is loaded
                if (typeof butterchurn === 'undefined' || typeof butterchurnPresets === 'undefined') {
                    console.error('[Control] Butterchurn library not loaded - skipping preview');
                    return;
                }

                stagedMilkdropIndex = index;

                // Initialize Milkdrop if not exists
                if (!milkdropPreviewVisualizer) {
                    console.log('[Control] Creating Milkdrop preview visualizer...');
                    const canvas = document.getElementById('milkdrop-preview-canvas');
                    canvas.width = 640;
                    canvas.height = 360;

                    // Create AudioContext for butterchurn
                    milkdropPreviewAudioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Try both API variations (butterchurn vs butterchurn.default)
                    const butterchurnAPI = butterchurn.createVisualizer ? butterchurn : (butterchurn.default || butterchurn);

                    if (!butterchurnAPI.createVisualizer) {
                        console.error('[Control] Butterchurn API not available - createVisualizer not found');
                        console.log('[Control] Available butterchurn properties:', Object.keys(butterchurn));
                        return;
                    }

                    // Create butterchurn instance
                    milkdropPreviewVisualizer = butterchurnAPI.createVisualizer(milkdropPreviewAudioContext, canvas, {
                        width: 640,
                        height: 360,
                        pixelRatio: 1,
                        meshWidth: 32,
                        meshHeight: 24
                    });

                    console.log('[Control] ✓ Milkdrop preview visualizer created');
                }

                // Show preview container
                document.getElementById('milkdrop-preview-container').style.display = 'block';

                // Load preset
                const allPresets = butterchurnPresets.getPresets();
                const presetKey = milkdropPresetList[index];
                const preset = allPresets[presetKey];

                if (!preset) {
                    console.error('[Control] Preset not found:', presetKey);
                    return;
                }

                milkdropPreviewVisualizer.loadPreset(preset, 0); // 0 = no blend transition
                console.log('[Control] ✓ Previewing Milkdrop preset:', presetKey);

                // Start render loop if not already running
                if (!window.milkdropPreviewAnimating) {
                    window.milkdropPreviewAnimating = true;
                    function animateMilkdropPreview() {
                        if (milkdropPreviewVisualizer) {
                            try {
                                milkdropPreviewVisualizer.render();
                                requestAnimationFrame(animateMilkdropPreview);
                            } catch (err) {
                                console.error('[Control] Milkdrop render error:', err);
                                window.milkdropPreviewAnimating = false;
                            }
                        }
                    }
                    animateMilkdropPreview();
                }
            } catch (error) {
                console.error('[Control] Failed to preview Milkdrop preset:', error);
                console.error('[Control] Error stack:', error.stack);
                // Don't show alert - just log error to avoid blocking UI
            }
        }

        // MIDI for optional external control
        let midiAccess = null;
        let midiOutput = null;

        // Send command to main tab via BroadcastChannel
        function sendCommand(command, data) {
            const message = { command, data };
            controlChannel.postMessage(message);
            console.log('[Control] Sent:', message);
        }

        // Receive state updates from main tab
        controlChannel.onmessage = (event) => {
            const { type, data } = event.data;

            switch (type) {
                case 'stateUpdate':
                    updateState(data);
                    break;
                case 'presetList':
                    displayPresets(data);
                    break;
            }
        };

        function updateState(state) {
            // Update connection status
            document.getElementById('connection-status').classList.add('connected');

            // Update BPM and position
            if (state.bpm !== undefined) {
                document.getElementById('current-bpm').textContent = state.bpm;
            }
            if (state.position !== undefined) {
                document.getElementById('current-position').textContent = state.position;
            }

            // Update audio device selection
            if (state.audioDeviceId !== undefined) {
                const audioSelect = document.getElementById('audio-device-select');
                audioSelect.value = state.audioDeviceId;
            }

            // Update EQ bars
            if (state.frequency !== undefined) {
                const bass = Math.min(100, Math.round((state.frequency.bass || 0) * 100));
                const mid = Math.min(100, Math.round((state.frequency.mid || 0) * 100));
                const high = Math.min(100, Math.round((state.frequency.high || 0) * 100));

                document.getElementById('bass-bar').style.height = `${bass}%`;
                document.getElementById('mid-bar').style.height = `${mid}%`;
                document.getElementById('high-bar').style.height = `${high}%`;
            }

            // Update SPP indicator
            if (state.sppActive === true) {
                const sppIndicator = document.getElementById('spp-indicator');
                sppIndicator.classList.add('spp');
                // Remove after animation completes
                setTimeout(() => {
                    sppIndicator.classList.remove('spp');
                }, 300);
            }

            // Update visual audio source - ALWAYS from main app state, NEVER from saved settings
            if (state.visualAudioSource !== undefined) {
                const dropdown = document.getElementById('milkdrop-audio-source');
                dropdown.value = state.visualAudioSource;
                // Removed spam log - broadcasts every 100ms

                // Show/hide MIDI options based on source
                const midiOptions = document.getElementById('midi-synth-options');
                midiOptions.style.display = state.visualAudioSource === 'midi' ? 'block' : 'none';
            }

            // Update MIDI synth settings
            if (state.midiSynthChannel !== undefined) {
                document.getElementById('midi-synth-channel').value = state.midiSynthChannel;
            }
            if (state.midiSynthAudible !== undefined) {
                document.getElementById('midi-synth-audible').checked = state.midiSynthAudible === 'true';
            }

            // Update current mode display and track program mode
            if (state.mode) {
                currentProgramMode = state.mode; // Track current program mode
                const modeNames = { builtin: 'Built-in', threejs: 'Three.js', milkdrop: 'Milkdrop', video: 'Video' };
                document.getElementById('current-mode-display').textContent = modeNames[state.mode] || state.mode;

                // Show/hide scene display based on mode
                const sceneDisplay = document.getElementById('program-scene-display');
                if (state.mode === 'builtin' && state.scene !== undefined) {
                    currentProgramScene = state.scene; // Track current scene
                    const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
                    document.getElementById('program-scene-name').textContent = sceneNames[state.scene] || state.scene;
                    sceneDisplay.style.display = '';
                } else {
                    sceneDisplay.style.display = 'none';
                }

                // Update Built-in section program display
                const builtinProgramDisplay = document.getElementById('program-builtin-display');
                if (state.mode === 'builtin' && state.scene !== undefined) {
                    const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
                    document.getElementById('program-builtin-name').textContent = sceneNames[state.scene];
                    builtinProgramDisplay.style.display = '';
                } else {
                    builtinProgramDisplay.style.display = 'none';
                }
            }

            // DON'T sync scene buttons from program - they represent what's staged, not what's on program
            // Scene button styling is controlled by previewBuiltinScene() function

            // Update program preset name (what's on main display)
            if (state.presetName && state.mode === 'milkdrop') {
                const programPresetDisplay = document.getElementById('program-preset-display');
                const programPresetName = document.getElementById('program-preset-name');
                programPresetName.textContent = state.presetName;
                programPresetDisplay.style.display = '';
            } else {
                const programPresetDisplay = document.getElementById('program-preset-display');
                if (programPresetDisplay) {
                    programPresetDisplay.style.display = 'none';
                }
            }

            // Update audio source display
            if (state.audioSourceDisplay) {
                document.getElementById('current-audio-source').textContent = state.audioSourceDisplay;
            }

            // Update MIDI input device
            if (state.midiInputId !== undefined) {
                const midiSelect = document.getElementById('midi-input-select');
                if (midiSelect && midiSelect.querySelector(`option[value="${state.midiInputId}"]`)) {
                    midiSelect.value = state.midiInputId;
                }
            }

            // Update SysEx setting
            if (state.enableSysEx !== undefined) {
                document.getElementById('sysex-enable').value = state.enableSysEx;
            }

            // Update program renderer display (what's actually on main display)
            if (state.renderer !== undefined && state.mode === 'builtin') {
                currentProgramRenderer = state.renderer; // Track current program renderer
                const rendererNames = { webgl: 'WebGL', canvas2d: 'Canvas 2D' };
                document.getElementById('program-renderer-name').textContent = rendererNames[state.renderer] || state.renderer;
                document.getElementById('program-renderer-display').style.display = '';

                // Only initialize staged renderer dropdown once on first state update
                if (!window.rendererInitialized) {
                    currentRendererMode = state.renderer;
                    document.getElementById('renderer-select').value = state.renderer;
                    window.rendererInitialized = true;
                }
            } else {
                const rendererDisplay = document.getElementById('program-renderer-display');
                if (rendererDisplay) {
                    rendererDisplay.style.display = 'none';
                }
            }

            // Update OSC server
            if (state.oscServer !== undefined) {
                document.getElementById('osc-server').value = state.oscServer;
            }

            // Update video device selection
            if (state.videoDeviceId !== undefined) {
                const videoSelect = document.getElementById('video-device-select');
                if (videoSelect && videoSelect.querySelector(`option[value="${state.videoDeviceId}"]`)) {
                    videoSelect.value = state.videoDeviceId;
                }
            }

            // Update video audio reactive toggle
            if (state.videoAudioReactive !== undefined) {
                document.getElementById('video-audio-reactive').checked = state.videoAudioReactive === 'true';
            }

            // Update video beat reactive toggle
            if (state.videoBeatReactive !== undefined) {
                document.getElementById('video-beat-reactive').checked = state.videoBeatReactive === 'true';
            }
        }


        // Load preset list from main app (not local config)
        // This is now handled by 'requestState' which triggers 'presetList' broadcast
        async function loadPresets() {
            console.log('[Control] Preset list will be loaded from main app via BroadcastChannel');
            // No local loading - main app is source of truth
        }

        function displayPresets(presets) {
            if (!presets || presets.length === 0) {
                return;
            }

            // Store preset list for staging
            milkdropPresetList = presets;

            const list = document.getElementById('preset-list');
            list.innerHTML = '';

            presets.forEach((preset, index) => {
                const item = document.createElement('div');
                item.className = 'preset-item';
                item.textContent = `${index}: ${preset}`;
                item.dataset.index = index;
                item.dataset.preset = preset;
                list.appendChild(item);
            });
        }

        // Event delegation for preset clicks - LOAD preset into unified preview
        document.getElementById('preset-list').addEventListener('click', (e) => {
            const item = e.target.closest('.preset-item');
            if (item) {
                const index = parseInt(item.dataset.index);

                // Update active state
                document.querySelectorAll('.preset-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');

                // Update staged index
                stagedMilkdropIndex = index;

                // If currently in milkdrop preview mode, load the preset immediately
                if (currentPreviewMode === 'milkdrop' && unifiedMilkdropVisualizer) {
                    const allPresets = butterchurnPresets.getPresets();
                    const presetKey = milkdropPresetList[index];
                    const preset = allPresets[presetKey];

                    if (preset) {
                        unifiedMilkdropVisualizer.loadPreset(preset, 0);
                        document.getElementById('staged-name').textContent = presetKey;
                        console.log('[Control] ✓ Loaded preset:', presetKey);
                    }
                } else {
                    // Just stage it - will load when user switches to milkdrop tab
                    console.log('[Control] Preset staged - switch to Milkdrop tab to preview');
                }
            }
        });

        // Audio device selection
        document.getElementById('audio-device-select').addEventListener('change', (e) => {
            sendCommand('audioDeviceSelect', e.target.value);
        });

        // Milkdrop audio source selection
        document.getElementById('milkdrop-audio-source').addEventListener('change', (e) => {
            const source = e.target.value;
            sendCommand('milkdropAudioSource', source);

            // Show/hide MIDI synth options
            const midiOptions = document.getElementById('midi-synth-options');
            midiOptions.style.display = source === 'midi' ? 'block' : 'none';
        });

        // MIDI synth channel
        document.getElementById('midi-synth-channel').addEventListener('change', (e) => {
            sendCommand('midiSynthChannel', e.target.value);
        });

        // MIDI synth audible toggle
        document.getElementById('midi-synth-audible').addEventListener('change', (e) => {
            sendCommand('midiSynthAudible', e.target.checked ? 'true' : 'false');
        });

        // MIDI input device selection
        document.getElementById('midi-input-select').addEventListener('change', (e) => {
            sendCommand('midiInputSelect', e.target.value);
        });

        // SysEx enable
        document.getElementById('sysex-enable').addEventListener('change', (e) => {
            sendCommand('sysexEnable', e.target.value);
        });

        // Renderer selection - STAGE ONLY (don't send to program immediately)
        document.getElementById('renderer-select').addEventListener('change', (e) => {
            const newMode = e.target.value;
            currentRendererMode = newMode;
            console.log('[Control] Renderer changed to:', newMode);

            // Reinitialize unified preview if builtin mode is active
            if (currentPreviewMode === 'builtin' && unifiedPreviewRenderer) {
                console.log('[Control] Reinitializing preview with new renderer...');
                unifiedPreviewRenderer.stop();
                unifiedPreviewRenderer = new VisualRenderer('unified-preview-canvas');
                unifiedPreviewRenderer.initialize(currentRendererMode);
                unifiedSceneManager = new SceneManager(unifiedPreviewRenderer);
                unifiedSceneManager.switchScene(stagedBuiltinScene);
                unifiedPreviewRenderer.start();
                console.log('[Control] ✓ Preview reinitialized');
            }

            // DON'T send to main app - only send when user clicks GO TO PROGRAM
        });

        // OSC server
        document.getElementById('osc-server').addEventListener('change', (e) => {
            sendCommand('oscServer', e.target.value);
        });

        // Video device selection - show preview first
        document.getElementById('video-device-select').addEventListener('change', async (e) => {
            const deviceId = e.target.value;
            stagedVideoDeviceId = deviceId;

            if (!deviceId) {
                console.log('[Control] No camera selected');
                // If currently in video preview mode, clear it
                if (currentPreviewMode === 'video') {
                    const ctx = unifiedCanvas.getContext('2d');
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, unifiedCanvas.width, unifiedCanvas.height);
                    ctx.fillStyle = '#888';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Select a camera below', unifiedCanvas.width / 2, unifiedCanvas.height / 2);
                    document.getElementById('staged-name').textContent = 'No camera selected';

                    // Release renderer
                    if (unifiedPreviewRenderer) {
                        unifiedPreviewRenderer.release();
                        unifiedPreviewRenderer = null;
                    }
                }
                return;
            }

            console.log('[Control] Camera selected:', deviceId);

            // If currently in video preview mode, reload preview with new camera
            if (currentPreviewMode === 'video') {
                // Release old camera
                if (unifiedPreviewRenderer) {
                    console.log('[Control] Releasing previous camera...');
                    unifiedPreviewRenderer.release();
                    await new Promise(resolve => setTimeout(resolve, 300));
                    unifiedPreviewRenderer = null;
                }

                // Load new camera
                await initVideoPreview();
            } else {
                // Just staged - will load when user switches to video tab
                console.log('[Control] Camera staged - switch to Video tab to preview');
            }
        });

        // Video audio reactive toggle
        document.getElementById('video-audio-reactive').addEventListener('change', (e) => {
            sendCommand('videoAudioReactive', e.target.checked ? 'true' : 'false');
        });

        // Video beat reactive toggle
        document.getElementById('video-beat-reactive').addEventListener('change', (e) => {
            sendCommand('videoBeatReactive', e.target.checked ? 'true' : 'false');
        });

        // Populate audio devices
        // NOTE: Devices need permission granted first to show proper labels
        // Permission should already be granted by index.html on load
        async function loadAudioDevices() {
            const select = document.getElementById('audio-device-select');
            const warning = document.getElementById('audio-perm-warning');
            select.innerHTML = '<option value="none">No Audio Input</option>';

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');

                // Check if we have permission (devices will have labels)
                const hasPermission = audioInputs.length > 0 && audioInputs[0].label !== '';

                if (!hasPermission && audioInputs.length > 0) {
                    // Devices exist but no labels = permission not granted
                    console.log('[Control] Audio permission not granted - device labels are empty');
                    console.log('[Control] ⚠️ Click PERMISSIONS button in index.html to grant audio access');
                    warning.style.display = 'inline';
                    return;
                }

                // Hide warning - permission granted
                warning.style.display = 'none';

                if (audioInputs.length === 0) {
                    console.log('[Control] No audio input devices found');
                    select.innerHTML = '<option value="none">No audio devices found</option>';
                    return;
                }

                // We have permission - show device names
                audioInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label;
                    select.appendChild(option);
                });

                console.log('[Control] Found', audioInputs.length, 'audio devices with labels');
            } catch (error) {
                console.error('[Control] Failed to enumerate audio devices:', error.message);
                select.innerHTML = '<option value="none">Error loading audio devices</option>';
            }
        }

        // Populate MIDI devices
        // NOTE: MIDI is OPTIONAL - browser may not support it or it may require HTTPS
        async function loadMIDIDevices() {
            const select = document.getElementById('midi-input-select');
            const warning = document.getElementById('midi-perm-warning');

            try {
                // Only request if not already available (won't trigger new prompt if granted)
                const access = await navigator.requestMIDIAccess();
                select.innerHTML = '';

                // Hide warning - MIDI is available
                warning.style.display = 'none';

                const inputs = Array.from(access.inputs.values());

                if (inputs.length === 0) {
                    select.innerHTML = '<option value="">No MIDI devices found</option>';
                    console.log('[Control] MIDI access granted but no devices connected');
                    return;
                }

                inputs.forEach(input => {
                    const option = document.createElement('option');
                    option.value = input.id;
                    option.textContent = input.name;
                    select.appendChild(option);
                });

                console.log('[Control] Found', inputs.length, 'MIDI devices');
            } catch (error) {
                // MIDI not available - this is OPTIONAL, so just hide warning and show message
                console.log('[Control] MIDI not available:', error.message);
                console.log('[Control] This is optional - browser may not support MIDI or requires HTTPS');

                // Hide warning - MIDI is optional, not required
                warning.style.display = 'none';

                select.innerHTML = '<option value="">MIDI not available (browser may not support it)</option>';
            }
        }

        // Populate video devices
        async function loadVideoDevices() {
            const select = document.getElementById('video-device-select');
            const warning = document.getElementById('video-perm-warning');
            select.innerHTML = '<option value="">No camera selected</option>';

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoInputs = devices.filter(device => device.kind === 'videoinput');

                // Check if we have permission (devices will have labels)
                const hasPermission = videoInputs.length > 0 && videoInputs[0].label !== '';

                if (!hasPermission && videoInputs.length > 0) {
                    // Devices exist but no labels = permission not granted
                    console.log('[Control] Video permission not granted - device labels are empty');
                    console.log('[Control] ⚠️ Click PERMISSIONS button in index.html to grant camera access');
                    warning.style.display = 'inline';
                    return;
                }

                // Hide warning - permission granted
                warning.style.display = 'none';

                videoInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label;
                    select.appendChild(option);
                });

                console.log('[Control] Found', videoInputs.length, 'video devices with labels');
            } catch (error) {
                console.error('[Control] Failed to enumerate video devices:', error.message);
            }
        }

        // Force dropdown to default to "microphone" on load
        // Main app will NEVER auto-start MIDI synth, so this is always correct initially
        document.getElementById('milkdrop-audio-source').value = 'microphone';
        document.getElementById('midi-synth-options').style.display = 'none';
        console.log('[Control] Defaulted to Audio Input Device');

        // CRITICAL: Force main app to microphone mode on control.html load
        // This ensures MIDI synth is never auto-started
        console.log('[Control] Forcing Visual Reactive Input to microphone...');
        sendCommand('milkdropAudioSource', 'microphone');

        // Initialize unified preview system
        console.log('[Control] Initializing unified preview system...');
        unifiedCanvas = document.getElementById('unified-preview-canvas');

        // Start with built-in preview by default
        setTimeout(() => {
            switchPreviewMode('builtin');
        }, 100);

        // Initialize
        loadPresets();
        loadAudioDevices();
        loadMIDIDevices();
        loadVideoDevices();

        // Request full state after a short delay (allows commands to be processed first)
        setTimeout(() => {
            console.log('[Control] Requesting state from main app...');
            sendCommand('requestState');
        }, 200);
    </script>
</body>
</html>

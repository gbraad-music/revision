<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Revision Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            padding: 20px;
        }

        h1 {
            font-size: 18px;
            margin-bottom: 20px;
            color: #888;
        }

        .section {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .section h2 {
            font-size: 14px;
            color: #0066FF;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        button {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #3a3a3a;
            padding: 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        button:hover {
            background: #3a3a3a;
            border-color: #4a4a4a;
        }

        button:active {
            background: #0066FF;
        }

        .status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #444;
            margin-right: 8px;
        }

        .status.connected {
            background: #00ff00;
            box-shadow: 0 0 8px #00ff00;
        }

        .status.spp {
            background: #ffcc00;
            box-shadow: 0 0 8px #ffcc00;
            animation: pulse-spp 0.3s ease-out;
        }

        @keyframes pulse-spp {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .eq-container {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            align-items: flex-end;
            height: 120px;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            padding: 10px;
        }

        .eq-bar {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            height: 100%;
        }

        .eq-bar-container {
            width: 100%;
            flex: 1;
            background: #1a1a1a;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
            margin-bottom: 25px;
        }

        /* Dark containers */
        .eq-bar-container {
            background: #0a0a0a;
        }

        /* Bar fills with gradients that stay fixed to container height */
        .eq-bar-fill {
            width: 100%;
            border-radius: 3px;
            position: absolute;
            bottom: 0;
            height: 0%;
            transition: height 0.05s ease-out;
            background-size: 100% 100px;
            background-position: bottom;
            background-repeat: no-repeat;
        }

        /* Bass - red/orange/yellow gradient */
        .eq-bar:nth-child(1) .eq-bar-fill {
            background-image: linear-gradient(to top, #660000, #FF2200, #FF6600, #FFAA00);
            box-shadow: 0 0 15px rgba(255, 102, 0, 0.8);
        }

        /* Mid - green/lime/yellow gradient */
        .eq-bar:nth-child(2) .eq-bar-fill {
            background-image: linear-gradient(to top, #003300, #00CC00, #66FF00, #CCFF00);
            box-shadow: 0 0 15px rgba(102, 255, 0, 0.8);
        }

        /* High - blue/cyan gradient */
        .eq-bar:nth-child(3) .eq-bar-fill {
            background-image: linear-gradient(to top, #002266, #0066FF, #00AAFF, #00FFFF);
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.8);
        }

        .eq-label {
            font-size: 9px;
            color: #666;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        select {
            width: 100%;
            background: #0a0a0a;
            color: #fff;
            border: 1px solid #2a2a2a;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .preset-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .preset-item {
            padding: 12px 15px;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            margin-bottom: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            user-select: none; /* Prevent text selection interfering with clicks */
            -webkit-user-select: none;
            transition: background 0.1s ease;
        }

        .preset-item:hover {
            background: #2a2a2a;
        }

        .preset-item.active {
            background: #0066FF;
            border-color: #0088FF;
        }
    </style>
</head>
<body>
    <h1>REVISION CONTROL</h1>

    <div class="section">
        <h2><span class="status" id="connection-status"></span>Connection <span class="status" id="spp-indicator" title="SPP Activity"></span></h2>
        <div class="info">Connected to main tab via BroadcastChannel</div>
        <div class="info" style="margin-top: 5px;">Mode: <span id="current-mode" style="color: #0066FF;">-</span></div>
        <div class="info" style="margin-top: 5px;">BPM: <span id="current-bpm" style="color: #0066FF;">-</span> | Position: <span id="current-position" style="color: #0066FF;">-</span></div>
        <div class="info" style="margin-top: 5px;">Audio Source: <span id="current-audio-source" style="color: #0066FF;">-</span></div>
    </div>

    <div class="section">
        <h2>Audio Information</h2>
        <div class="eq-container">
            <div class="eq-bar">
                <div class="eq-bar-container">
                    <div class="eq-bar-fill" id="bass-bar" style="height: 0%;"></div>
                </div>
                <div class="eq-label">Bass</div>
            </div>
            <div class="eq-bar">
                <div class="eq-bar-container">
                    <div class="eq-bar-fill" id="mid-bar" style="height: 0%;"></div>
                </div>
                <div class="eq-label">Mid</div>
            </div>
            <div class="eq-bar">
                <div class="eq-bar-container">
                    <div class="eq-bar-fill" id="high-bar" style="height: 0%;"></div>
                </div>
                <div class="eq-label">High</div>
            </div>
        </div>
        <div class="info">Real-time frequency analysis from active audio source</div>
    </div>

    <div class="section">
        <h2>MIDI Device <span id="midi-perm-warning" style="color: #ff6600; font-size: 11px; display: none;">‚ö†Ô∏è Permission required - click PERMISSIONS in main window</span></h2>
        <select id="midi-input-select">
            <option value="">No MIDI devices found</option>
        </select>
        <div class="info">MIDI input device for clock, SPP, and notes</div>

        <label style="font-size: 11px; color: #888; text-transform: uppercase; display: block; margin-top: 15px; margin-bottom: 5px;">Enable SysEx</label>
        <select id="sysex-enable">
            <option value="true">Yes (requires permission)</option>
            <option value="false">No</option>
        </select>
        <div class="info" style="margin-top: 5px;">Allow MIDI SysEx messages (requires page reload)</div>
    </div>

    <div class="section">
        <h2>Audio Input <span id="audio-perm-warning" style="color: #ff6600; font-size: 11px; display: none;">‚ö†Ô∏è Permission required - click PERMISSIONS in main window</span></h2>
        <select id="audio-device-select">
            <option value="none">No Audio Input</option>
        </select>
        <div class="info">Select microphone or audio input device</div>
    </div>

    <div class="section">
        <h2>Visual Reactive Input</h2>
        <select id="milkdrop-audio-source">
            <option value="microphone" selected>Audio Input Device</option>
            <option value="midi">MIDI Synthesizer</option>
        </select>

        <div id="midi-synth-options" style="margin-top: 10px;">
            <label style="font-size: 11px; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px;">MIDI Channel Filter</label>
            <select id="midi-synth-channel">
                <option value="all">All MIDI Channels</option>
                <option value="0">MIDI Channel 1</option>
                <option value="1">MIDI Channel 2</option>
                <option value="2">MIDI Channel 3</option>
                <option value="3">MIDI Channel 4</option>
                <option value="4">MIDI Channel 5</option>
                <option value="5">MIDI Channel 6</option>
                <option value="6">MIDI Channel 7</option>
                <option value="7">MIDI Channel 8</option>
                <option value="8">MIDI Channel 9</option>
                <option value="9">MIDI Channel 10 (Drums)</option>
                <option value="10">MIDI Channel 11</option>
                <option value="11">MIDI Channel 12</option>
                <option value="12">MIDI Channel 13</option>
                <option value="13">MIDI Channel 14</option>
                <option value="14">MIDI Channel 15</option>
                <option value="15">MIDI Channel 16</option>
            </select>

            <label style="display: block; margin-top: 10px; font-size: 12px;">
                <input type="checkbox" id="midi-synth-audible" style="width: auto; margin-right: 5px;">
                Make MIDI synth audible (hear the notes)
            </label>
        </div>

        <div class="info">Audio source for ALL visual renderers (Three.js, Milkdrop, Waveform)</div>
    </div>

    <div class="section">
        <h2>PROGRAM Output</h2>
        <div class="info">Mode: <span id="current-mode-display" style="color: #00ff00; font-weight: bold;">-</span></div>
        <div class="info" id="program-builtin-display" style="margin-top: 5px; display: none;">Scene: <span id="program-builtin-name" style="color: #00ff00; font-weight: bold;">-</span></div>
        <div class="info" id="program-preset-display" style="margin-top: 5px; display: none;">Preset: <span id="program-preset-name" style="color: #00ff00; font-weight: bold;">-</span></div>
        <div class="info" id="program-renderer-display" style="margin-top: 5px; display: none;">Renderer: <span id="program-renderer-name" style="color: #00ff00; font-weight: bold;">-</span></div>
    </div>

    <div class="section">
        <h2>PREVIEW / Program</h2>

        <!-- Mode Selector Tabs -->
        <div style="display: flex; gap: 5px; margin-bottom: 15px;">
            <button onclick="switchPreviewMode('builtin')" id="preview-tab-builtin" style="flex: 1; padding: 10px; background: #0066FF; border: 1px solid #0088FF; border-radius: 4px; color: white; font-weight: bold; cursor: pointer;">Built-in</button>
            <button onclick="switchPreviewMode('threejs')" id="preview-tab-threejs" style="flex: 1; padding: 10px; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 4px; color: #888; font-weight: bold; cursor: pointer;">Three.js</button>
            <button onclick="switchPreviewMode('milkdrop')" id="preview-tab-milkdrop" style="flex: 1; padding: 10px; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 4px; color: #888; font-weight: bold; cursor: pointer;">Milkdrop</button>
            <button onclick="switchPreviewMode('video')" id="preview-tab-video" style="flex: 1; padding: 10px; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 4px; color: #888; font-weight: bold; cursor: pointer;">Camera</button>
            <button onclick="switchPreviewMode('media')" id="preview-tab-media" style="flex: 1; padding: 10px; background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 4px; color: #888; font-weight: bold; cursor: pointer;">Media</button>
        </div>

        <!-- Single Unified Preview Canvas -->
        <div id="unified-preview-container" style="margin-bottom: 15px; max-width: 640px;">
            <div style="position: relative; background: #000; border: 2px solid #0066FF; border-radius: 4px; overflow: hidden; width: 100%; padding-bottom: 56.25%; /* 16:9 aspect ratio */">
                <canvas id="unified-preview-canvas" width="640" height="360" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block;"></canvas>
                <div style="position: absolute; top: 5px; left: 5px; background: rgba(0,102,255,0.8); color: white; padding: 3px 8px; border-radius: 3px; font-size: 10px; font-weight: bold; z-index: 10;">PREVIEW</div>
                <div id="preview-mode-label" style="position: absolute; top: 5px; right: 5px; background: rgba(0,102,255,0.8); color: white; padding: 3px 8px; border-radius: 3px; font-size: 10px; font-weight: bold; z-index: 10;">BUILT-IN</div>
            </div>
        </div>

        <div class="info" id="staged-info" style="margin-bottom: 10px;">Staged: <span id="staged-name" style="color: #0066FF; font-weight: bold;">1 - Tunnel</span></div>

        <!-- Single GO TO PROGRAM Button -->
        <button onclick="goToProgram()" style="width: 100%; padding: 15px; background: #00aa00; border: 2px solid #00cc00; border-radius: 4px; color: white; font-weight: bold; font-size: 14px; cursor: pointer;">‚ñ∂ GO TO PROGRAM</button>
    </div>

    <!-- Built-in Scene Controls -->
    <div class="section" id="builtin-controls" style="display: block;">
        <h2>Built-in Scenes</h2>

        <label style="font-size: 11px; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px;">Renderer Mode</label>
        <select id="renderer-select" style="width: 100%; margin-bottom: 15px;">
            <option value="webgl">WebGL (Recommended)</option>
            <option value="canvas2d">Canvas 2D</option>
        </select>

        <div class="button-grid">
            <button onclick="previewBuiltinScene(0)" id="scene-0">Scene 1<br><small>Tunnel</small></button>
            <button onclick="previewBuiltinScene(1)" id="scene-1">Scene 2<br><small>Particles</small></button>
            <button onclick="previewBuiltinScene(2)" id="scene-2">Scene 3<br><small>Kaleidoscope</small></button>
            <button onclick="previewBuiltinScene(3)" id="scene-3">Scene 4<br><small>Waveform</small></button>
        </div>
    </div>

    <!-- Milkdrop Preset Controls -->
    <div class="section" id="milkdrop-controls" style="display: none;">
        <h2>Milkdrop Presets</h2>

        <div class="button-grid">
            <button onclick="stageMilkdropNav('prev')">‚óÄ Previous</button>
            <button onclick="stageMilkdropNav('next')">Next ‚ñ∂</button>
        </div>

        <div class="preset-list" id="preset-list">
            <!-- Populated dynamically -->
        </div>
    </div>

    <!-- Three.js Preset Controls -->
    <div class="section" id="threejs-controls" style="display: none;">
        <h2>Three.js Presets</h2>

        <div class="button-grid">
            <button onclick="stageThreeJSNav('prev')">‚óÄ Previous</button>
            <button onclick="stageThreeJSNav('next')">Next ‚ñ∂</button>
        </div>

        <div class="button-grid" id="threejs-preset-grid" style="margin-top: 15px;">
            <button onclick="previewThreeJSPreset(0)" id="threejs-preset-0">Geometric<br><small>Shapes</small></button>
            <button onclick="previewThreeJSPreset(1)" id="threejs-preset-1">Particles<br><small>Field</small></button>
            <button onclick="previewThreeJSPreset(2)" id="threejs-preset-2">Tunnel<br><small>Infinity</small></button>
        </div>
    </div>

    <!-- Video Camera Controls -->
    <div class="section" id="video-controls" style="display: none;">
        <h2>Camera Feed <span id="video-perm-warning" style="color: #ff6600; font-size: 11px; display: none;">‚ö†Ô∏è Permission required - click PERMISSIONS in main window</span></h2>

        <select id="video-device-select">
            <option value="">No camera selected</option>
        </select>
        <div class="info" style="margin-top: 5px;">Select camera for preview</div>

        <label style="display: block; margin-top: 15px; font-size: 12px;">
            <input type="checkbox" id="video-audio-reactive" style="width: auto; margin-right: 5px;">
            Audio-reactive color effects (hue, saturation, brightness)
        </label>

        <label style="display: block; margin-top: 10px; font-size: 12px;">
            <input type="checkbox" id="video-beat-reactive" style="width: auto; margin-right: 5px;">
            Beat-reactive zoom pulse (4-on-the-floor)
        </label>

        <div style="margin-top: 15px;">
            <button onclick="sendCommand('videoRelease')" style="width: 100%; padding: 10px;">Release Program Camera</button>
            <div class="info" style="margin-top: 5px;">Release camera on main display</div>
        </div>
    </div>

    <!-- Media File Controls (Images & Videos) -->
    <div class="section" id="media-controls" style="display: none;">
        <h2>Media Files (Images & Videos)</h2>

        <label style="font-size: 11px; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px;">Select or Drop Media File</label>
        <div id="media-drop-zone" style="width: 100%; padding: 30px; background: #0a0a0a; color: #666; border: 2px dashed #2a2a2a; border-radius: 4px; text-align: center; cursor: pointer; transition: all 0.2s; margin-bottom: 10px;">
            <div style="font-size: 14px; margin-bottom: 5px;">üìÅ Drop media file here</div>
            <div style="font-size: 11px;">or click to browse</div>
        </div>
        <input type="file" id="media-file-input" accept="image/*,video/*" style="display: none;">
        <div class="info">Supports images (JPG, PNG, GIF) and videos (MP4, WebM)</div>

        <div id="media-file-info" style="margin-top: 15px; padding: 10px; background: #0a0a0a; border: 1px solid #2a2a2a; border-radius: 4px; display: none;">
            <div style="font-size: 11px; color: #888; text-transform: uppercase; margin-bottom: 5px;">Selected File</div>
            <div id="media-file-name" style="color: #0066FF; font-weight: bold; margin-bottom: 5px;">-</div>
            <div id="media-file-type" style="font-size: 11px; color: #888;">-</div>
            <div id="media-file-size" style="font-size: 11px; color: #888; margin-top: 3px;">-</div>
        </div>

        <label style="font-size: 11px; color: #888; text-transform: uppercase; display: block; margin-top: 15px; margin-bottom: 5px;">Fit Mode</label>
        <select id="media-fit-mode" style="width: 100%; background: #0a0a0a; color: #fff; border: 1px solid #2a2a2a; padding: 10px; border-radius: 4px; margin-bottom: 5px;">
            <option value="cover">Cover (Fill, may crop)</option>
            <option value="contain">Contain (Fit all, may letterbox)</option>
            <option value="fill">Stretch (Fill, may distort)</option>
        </select>
        <div class="info" style="margin-bottom: 10px;">How media should fit in the canvas</div>

        <label style="display: block; margin-top: 10px; font-size: 12px;">
            <input type="checkbox" id="media-loop" style="width: auto; margin-right: 5px;" checked>
            Loop video playback
        </label>

        <label style="display: block; margin-top: 10px; font-size: 12px;">
            <input type="checkbox" id="media-audio-reactive" style="width: auto; margin-right: 5px;">
            Audio-reactive effects
        </label>

        <label style="display: block; margin-top: 10px; font-size: 12px;">
            <input type="checkbox" id="media-beat-reactive" style="width: auto; margin-right: 5px;">
            Beat-reactive zoom
        </label>

        <div style="margin-top: 15px;">
            <button onclick="clearMediaFile()" style="width: 100%; padding: 10px;">Clear Media</button>
            <div class="info" style="margin-top: 5px;">Clear loaded media file</div>
        </div>
    </div>

    <div class="section">
        <h2>Display Settings</h2>

        <label style="display: block; margin-bottom: 10px; font-size: 12px;">
            <input type="checkbox" id="show-status-bar" style="width: auto; margin-right: 5px;" checked>
            Show Status Bar (Top)
        </label>

        <label style="display: block; margin-bottom: 10px; font-size: 12px;">
            <input type="checkbox" id="show-control-panel" style="width: auto; margin-right: 5px;">
            Show Control Panel (Bottom)
        </label>

        <label style="display: block; margin-bottom: 10px; font-size: 12px;">
            <input type="checkbox" id="use-fullscreen" style="width: auto; margin-right: 5px;" disabled>
            Fullscreen Active (use F11 to toggle)
        </label>

        <div class="info">Press F11 on main display to enter/exit fullscreen mode</div>
    </div>

    <div class="section">
        <h2>OSC Server (Optional)</h2>
        <input type="text" id="osc-server" placeholder="ws://localhost:8080" style="width: 100%; background: #0a0a0a; color: #fff; border: 1px solid #2a2a2a; padding: 10px; border-radius: 4px;" />
        <div class="info">WebSocket OSC server for external control</div>
    </div>

    <!-- Butterchurn for Milkdrop preview (local files) -->
    <script src="external/butterchurn.min.js"></script>
    <script src="external/butterchurnPresets.min.js"></script>

    <!-- Three.js for 3D preview (global build) -->
    <script src="external/three.min.js"></script>

    <!-- Renderers for preview -->
    <script src="renderers/video-renderer.js"></script>
    <script src="visuals/renderer.js"></script>
    <script src="scenes/scene-manager.js"></script>
    <script src="presets/threejs-renderer.js"></script>
    <script src="presets/threejs/BasePreset.js"></script>

    <script>
        // BroadcastChannel for tab-to-tab communication
        const controlChannel = new BroadcastChannel('revision-control');

        // UNIFIED PREVIEW SYSTEM - Single canvas, one renderer at a time
        let currentPreviewMode = 'builtin'; // Which tab is active: builtin/threejs/milkdrop/video/media
        let unifiedCanvas = null;
        let unifiedPreviewRenderer = null; // VideoRenderer OR VisualRenderer
        let unifiedSceneManager = null; // For built-in scenes
        let unifiedThreeJSRenderer = null; // For Three.js
        let unifiedMilkdropVisualizer = null; // For Milkdrop
        let unifiedAudioContext = null;
        let currentVideoDeviceId = null;

        // Media file state
        let stagedMediaFile = null; // File object
        let stagedMediaURL = null; // Object URL for preview
        let stagedMediaType = null; // 'image' or 'video'
        let mediaElement = null; // IMG or VIDEO element for rendering
        let mediaFitMode = 'cover'; // How to fit media: cover, contain, fill

        // Current program state (synced from main app)
        let currentProgramMode = 'builtin';
        let currentProgramRenderer = 'webgl';
        let currentProgramScene = 0;

        // Staged renderer mode (for preview, not synced after init)
        let currentRendererMode = 'webgl';

        // Staged state (preview before sending to program)
        let stagedBuiltinScene = 0;
        let stagedMilkdropIndex = 0;
        let stagedThreeJSIndex = 0;
        let stagedVideoDeviceId = '';
        let milkdropPresetList = [];
        let threejsPresetList = ['geometric', 'particles', 'tunnel'];

        // UNIFIED GO TO PROGRAM - Single button for all modes
        function goToProgram() {
            console.log('[Control] GO TO PROGRAM - Preview Mode:', currentPreviewMode);

            switch (currentPreviewMode) {
                case 'builtin':
                    goToProgramBuiltin();
                    break;
                case 'threejs':
                    goToProgramThreeJS();
                    break;
                case 'milkdrop':
                    goToProgramMilkdrop();
                    break;
                case 'video':
                    goToProgramVideo();
                    break;
                case 'media':
                    goToProgramMedia();
                    break;
            }
        }

        function goToProgramBuiltin() {
            console.log('[Control] GO TO PROGRAM: Built-in Scene', stagedBuiltinScene, 'Renderer:', currentRendererMode);

            if (currentProgramMode === 'builtin') {
                // Already in builtin - just switch scene and renderer simultaneously
                sendCommand('switchScene', stagedBuiltinScene);
                sendCommand('rendererSelect', currentRendererMode);
            } else {
                // Switch to builtin mode first
                sendCommand('switchMode', 'builtin');
                setTimeout(() => {
                    sendCommand('switchScene', stagedBuiltinScene);
                    sendCommand('rendererSelect', currentRendererMode);
                }, 100);
            }
        }

        function goToProgramThreeJS() {
            console.log('[Control] GO TO PROGRAM: Three.js Preset', threejsPresetList[stagedThreeJSIndex]);
            sendCommand('switchMode', 'threejs');
            setTimeout(() => {
                sendCommand('threejsSelect', threejsPresetList[stagedThreeJSIndex]);
            }, 100);
        }

        function goToProgramMilkdrop() {
            console.log('[Control] GO TO PROGRAM: Milkdrop Preset', stagedMilkdropIndex);
            sendCommand('switchMode', 'milkdrop');
            setTimeout(() => {
                sendCommand('milkdropSelect', stagedMilkdropIndex);
            }, 100);
        }

        function goToProgramVideo() {
            console.log('[Control] GO TO PROGRAM: Video Camera', stagedVideoDeviceId);
            if (stagedVideoDeviceId) {
                sendCommand('switchMode', 'video');
                setTimeout(() => {
                    sendCommand('videoDeviceSelect', stagedVideoDeviceId);
                }, 100);
            } else {
                console.warn('[Control] No camera selected');
            }
        }

        // SWITCH PREVIEW MODE - Tabs for Built-in/Milkdrop/Video/Media
        function switchPreviewMode(mode) {
            console.log('[Control] Switching preview mode to:', mode);
            currentPreviewMode = mode;

            // Update tab button styles
            document.getElementById('preview-tab-builtin').style.background = mode === 'builtin' ? '#0066FF' : '#2a2a2a';
            document.getElementById('preview-tab-builtin').style.borderColor = mode === 'builtin' ? '#0088FF' : '#3a3a3a';
            document.getElementById('preview-tab-builtin').style.color = mode === 'builtin' ? 'white' : '#888';

            document.getElementById('preview-tab-threejs').style.background = mode === 'threejs' ? '#0066FF' : '#2a2a2a';
            document.getElementById('preview-tab-threejs').style.borderColor = mode === 'threejs' ? '#0088FF' : '#3a3a3a';
            document.getElementById('preview-tab-threejs').style.color = mode === 'threejs' ? 'white' : '#888';

            document.getElementById('preview-tab-milkdrop').style.background = mode === 'milkdrop' ? '#0066FF' : '#2a2a2a';
            document.getElementById('preview-tab-milkdrop').style.borderColor = mode === 'milkdrop' ? '#0088FF' : '#3a3a3a';
            document.getElementById('preview-tab-milkdrop').style.color = mode === 'milkdrop' ? 'white' : '#888';

            document.getElementById('preview-tab-video').style.background = mode === 'video' ? '#0066FF' : '#2a2a2a';
            document.getElementById('preview-tab-video').style.borderColor = mode === 'video' ? '#0088FF' : '#3a3a3a';
            document.getElementById('preview-tab-video').style.color = mode === 'video' ? 'white' : '#888';

            document.getElementById('preview-tab-media').style.background = mode === 'media' ? '#0066FF' : '#2a2a2a';
            document.getElementById('preview-tab-media').style.borderColor = mode === 'media' ? '#0088FF' : '#3a3a3a';
            document.getElementById('preview-tab-media').style.color = mode === 'media' ? 'white' : '#888';

            // Show/hide control sections
            document.getElementById('builtin-controls').style.display = mode === 'builtin' ? 'block' : 'none';
            document.getElementById('threejs-controls').style.display = mode === 'threejs' ? 'block' : 'none';
            document.getElementById('milkdrop-controls').style.display = mode === 'milkdrop' ? 'block' : 'none';
            document.getElementById('video-controls').style.display = mode === 'video' ? 'block' : 'none';
            document.getElementById('media-controls').style.display = mode === 'media' ? 'block' : 'none';

            // Update preview mode label
            const labels = { builtin: 'BUILT-IN', threejs: 'THREE.JS', milkdrop: 'MILKDROP', video: 'VIDEO', media: 'MEDIA' };
            document.getElementById('preview-mode-label').textContent = labels[mode];

            // Stop and cleanup old preview renderer
            cleanupPreview();

            // Start appropriate preview
            switch (mode) {
                case 'builtin':
                    initBuiltinPreview();
                    break;
                case 'threejs':
                    initThreeJSPreview();
                    break;
                case 'milkdrop':
                    initMilkdropPreview();
                    break;
                case 'video':
                    initVideoPreview();
                    break;
                case 'media':
                    initMediaPreview();
                    break;
            }
        }

        // CLEANUP PREVIEW - Stop current preview renderer
        function cleanupPreview() {
            console.log('[Control] Cleaning up preview renderer');

            // Stop video renderer
            if (unifiedPreviewRenderer && unifiedPreviewRenderer.release) {
                unifiedPreviewRenderer.release();
                unifiedPreviewRenderer = null;
            }

            // Stop built-in renderer
            if (unifiedPreviewRenderer && unifiedPreviewRenderer.stop) {
                unifiedPreviewRenderer.stop();
                unifiedPreviewRenderer = null;
            }

            // Stop Three.js renderer
            if (unifiedThreeJSRenderer && unifiedThreeJSRenderer.stop) {
                unifiedThreeJSRenderer.stop();
                unifiedThreeJSRenderer = null;
            }

            // Stop Milkdrop visualizer
            if (unifiedMilkdropVisualizer) {
                window.milkdropPreviewAnimating = false;
                unifiedMilkdropVisualizer = null;
            }

            // Stop media rendering
            if (window.mediaPreviewAnimating) {
                window.mediaPreviewAnimating = false;
            }

            unifiedSceneManager = null;
        }

        // INIT BUILT-IN PREVIEW
        function initBuiltinPreview() {
            console.log('[Control] Initializing built-in preview...');

            // Replace canvas if it was used for 2D rendering (from video mode)
            const oldCanvas = document.getElementById('unified-preview-canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'unified-preview-canvas';
            newCanvas.width = oldCanvas.clientWidth;
            newCanvas.height = oldCanvas.clientHeight;
            newCanvas.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block;';

            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            unifiedCanvas = newCanvas;
            console.log('[Control] Canvas refreshed for built-in mode');

            // Create renderer if not exists or mode changed
            if (!unifiedPreviewRenderer || unifiedPreviewRenderer.mode !== currentRendererMode) {
                if (unifiedPreviewRenderer) {
                    unifiedPreviewRenderer.stop();
                }
                unifiedPreviewRenderer = new VisualRenderer('unified-preview-canvas');
                unifiedPreviewRenderer.initialize(currentRendererMode);
                unifiedSceneManager = new SceneManager(unifiedPreviewRenderer);
                console.log('[Control] ‚úì Built-in renderer initialized with mode:', currentRendererMode);
            }

            // Load current staged scene
            unifiedSceneManager.switchScene(stagedBuiltinScene);
            unifiedPreviewRenderer.start();

            // Update staged name
            const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
            document.getElementById('staged-name').textContent = sceneNames[stagedBuiltinScene];
        }

        // INIT THREE.JS PREVIEW
        async function initThreeJSPreview() {
            console.log('[Control] Initializing Three.js preview...');

            if (typeof THREE === 'undefined') {
                console.error('[Control] THREE.js library not loaded');
                document.getElementById('staged-name').textContent = 'THREE.js not loaded';
                return;
            }

            console.log('[Control] THREE.js ready');

            // Replace canvas to ensure fresh WebGL context
            const oldCanvas = document.getElementById('unified-preview-canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'unified-preview-canvas';
            newCanvas.width = 640;
            newCanvas.height = 360;
            newCanvas.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block;';

            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            unifiedCanvas = newCanvas;
            console.log('[Control] Canvas refreshed for Three.js mode');

            // Create Three.js renderer if not exists
            if (!unifiedThreeJSRenderer) {
                try {
                    unifiedThreeJSRenderer = new ThreeJSRenderer(unifiedCanvas);
                    await unifiedThreeJSRenderer.initialize();
                    console.log('[Control] ‚úì Three.js renderer created');

                    // Load current staged preset on-demand
                    const presetKey = threejsPresetList[stagedThreeJSIndex];
                    const loaded = await loadThreeJSPreset(presetKey, true);

                    if (loaded) {
                        unifiedThreeJSRenderer.loadPreset(presetKey);
                        unifiedThreeJSRenderer.start();

                        // Update staged name
                        const presetNames = ['Geometric Shapes', 'Particles Field', 'Tunnel Infinity'];
                        document.getElementById('staged-name').textContent = presetNames[stagedThreeJSIndex];

                        console.log('[Control] ‚úì Three.js preview initialized with fresh preset:', presetKey);
                    }
                } catch (error) {
                    console.error('[Control] Failed to initialize Three.js renderer:', error);
                    document.getElementById('staged-name').textContent = 'Error loading Three.js';
                }
            } else {
                // Renderer exists, load preset on-demand
                const presetKey = threejsPresetList[stagedThreeJSIndex];
                const loaded = await loadThreeJSPreset(presetKey, true);

                if (loaded) {
                    unifiedThreeJSRenderer.loadPreset(presetKey);
                    if (!unifiedThreeJSRenderer.isAnimating) {
                        unifiedThreeJSRenderer.start();
                    }

                    // Update staged name
                    const presetNames = ['Geometric Shapes', 'Particles Field', 'Tunnel Infinity'];
                    document.getElementById('staged-name').textContent = presetNames[stagedThreeJSIndex];

                    console.log('[Control] ‚úì Three.js preview loaded fresh preset:', presetKey);
                }
            }
        }

        // INIT MILKDROP PREVIEW
        function initMilkdropPreview() {
            console.log('[Control] Initializing Milkdrop preview...');

            if (typeof butterchurn === 'undefined' || typeof butterchurnPresets === 'undefined') {
                console.error('[Control] Butterchurn library not loaded');
                document.getElementById('staged-name').textContent = 'Butterchurn not loaded';
                return;
            }

            // Replace canvas to ensure fresh WebGL context
            const oldCanvas = document.getElementById('unified-preview-canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'unified-preview-canvas';
            newCanvas.width = oldCanvas.clientWidth;
            newCanvas.height = oldCanvas.clientHeight;
            newCanvas.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block;';

            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            unifiedCanvas = newCanvas;
            console.log('[Control] Canvas refreshed for Milkdrop mode');

            const displayWidth = unifiedCanvas.width;
            const displayHeight = unifiedCanvas.height;
            console.log('[Control] Milkdrop canvas size:', displayWidth, 'x', displayHeight);

            if (!unifiedMilkdropVisualizer) {
                // Create AudioContext if needed
                if (!unifiedAudioContext) {
                    unifiedAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                const butterchurnAPI = butterchurn.createVisualizer ? butterchurn : (butterchurn.default || butterchurn);
                if (!butterchurnAPI.createVisualizer) {
                    console.error('[Control] Butterchurn API not available');
                    return;
                }

                // Create visualizer with actual canvas size
                unifiedMilkdropVisualizer = butterchurnAPI.createVisualizer(unifiedAudioContext, unifiedCanvas, {
                    width: displayWidth,
                    height: displayHeight,
                    pixelRatio: window.devicePixelRatio || 1,
                    meshWidth: 32,
                    meshHeight: 24
                });
                console.log('[Control] ‚úì Milkdrop visualizer created at', displayWidth, 'x', displayHeight);
            }

            // Load current preset
            if (milkdropPresetList.length > 0) {
                const allPresets = butterchurnPresets.getPresets();
                const presetKey = milkdropPresetList[stagedMilkdropIndex];
                const preset = allPresets[presetKey];

                if (preset) {
                    unifiedMilkdropVisualizer.loadPreset(preset, 0);
                    document.getElementById('staged-name').textContent = presetKey;
                    console.log('[Control] ‚úì Loaded preset:', presetKey);
                }
            } else {
                document.getElementById('staged-name').textContent = 'No presets available';
            }

            // Start render loop
            if (!window.milkdropPreviewAnimating) {
                window.milkdropPreviewAnimating = true;
                function animateMilkdropPreview() {
                    if (unifiedMilkdropVisualizer && window.milkdropPreviewAnimating) {
                        try {
                            unifiedMilkdropVisualizer.render();
                            requestAnimationFrame(animateMilkdropPreview);
                        } catch (err) {
                            console.error('[Control] Milkdrop render error:', err);
                            window.milkdropPreviewAnimating = false;
                        }
                    }
                }
                animateMilkdropPreview();
            }
        }

        // INIT VIDEO PREVIEW
        async function initVideoPreview() {
            console.log('[Control] Initializing video preview...');
            console.log('[Control] Staged device ID:', stagedVideoDeviceId);

            // CRITICAL: Get a fresh canvas element by replacing it
            // This is needed because we can't mix WebGL and 2D contexts
            const container = document.getElementById('unified-preview-container').querySelector('div');
            const oldCanvas = document.getElementById('unified-preview-canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'unified-preview-canvas';
            newCanvas.width = oldCanvas.clientWidth;
            newCanvas.height = oldCanvas.clientHeight;
            newCanvas.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block;';

            // Replace old canvas with new one
            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            unifiedCanvas = newCanvas;
            console.log('[Control] Canvas replaced for video mode');

            // If there's a staged camera, load it
            if (stagedVideoDeviceId) {
                try {
                    console.log('[Control] Creating VideoRenderer for canvas:', unifiedCanvas.id);
                    // Create fresh video renderer
                    unifiedPreviewRenderer = new VideoRenderer(unifiedCanvas);
                    console.log('[Control] VideoRenderer created, initializing with device:', stagedVideoDeviceId);

                    const success = await unifiedPreviewRenderer.initialize(stagedVideoDeviceId);
                    console.log('[Control] VideoRenderer initialize result:', success);

                    if (success) {
                        console.log('[Control] Starting video renderer...');
                        unifiedPreviewRenderer.start();
                        console.log('[Control] ‚úì Video preview started');

                        // Get device name for display
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        const device = devices.find(d => d.deviceId === stagedVideoDeviceId);
                        const deviceName = device ? device.label : stagedVideoDeviceId.substring(0, 20) + '...';
                        document.getElementById('staged-name').textContent = 'Camera: ' + deviceName;
                    } else {
                        console.error('[Control] ‚úó Failed to initialize video preview');
                        document.getElementById('staged-name').textContent = 'Failed to load camera';

                        // Show error message on canvas
                        const ctx = unifiedCanvas.getContext('2d');
                        if (ctx) {
                            ctx.fillStyle = '#000';
                            ctx.fillRect(0, 0, unifiedCanvas.width, unifiedCanvas.height);
                            ctx.fillStyle = '#ff0000';
                            ctx.font = '14px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText('Camera failed to load', unifiedCanvas.width / 2, unifiedCanvas.height / 2 - 10);
                            ctx.fillStyle = '#888';
                            ctx.font = '12px sans-serif';
                            ctx.fillText('Check permissions or try another camera', unifiedCanvas.width / 2, unifiedCanvas.height / 2 + 10);
                        }
                    }
                } catch (error) {
                    console.error('[Control] Exception initializing video preview:', error);
                    console.error('[Control] Error stack:', error.stack);
                    document.getElementById('staged-name').textContent = 'Error: ' + error.message;
                }
            } else {
                // Clear canvas and show message
                console.log('[Control] No camera selected, showing placeholder');
                const ctx = unifiedCanvas.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, unifiedCanvas.width, unifiedCanvas.height);
                    ctx.fillStyle = '#888';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Select a camera below', unifiedCanvas.width / 2, unifiedCanvas.height / 2);
                }
                document.getElementById('staged-name').textContent = 'No camera selected';
            }
        }

        // INIT MEDIA PREVIEW
        function initMediaPreview() {
            console.log('[Control] Initializing media preview...');

            // Replace canvas to ensure fresh 2D context
            const oldCanvas = document.getElementById('unified-preview-canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'unified-preview-canvas';
            newCanvas.width = oldCanvas.clientWidth;
            newCanvas.height = oldCanvas.clientHeight;
            newCanvas.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block;';

            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
            unifiedCanvas = newCanvas;
            console.log('[Control] Canvas refreshed for media mode');

            if (stagedMediaFile) {
                // Render the staged media file
                renderMediaPreview();
            } else {
                // Show placeholder
                const ctx = unifiedCanvas.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, unifiedCanvas.width, unifiedCanvas.height);
                    ctx.fillStyle = '#888';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Select a media file below', unifiedCanvas.width / 2, unifiedCanvas.height / 2);
                }
                document.getElementById('staged-name').textContent = 'No media selected';
            }
        }

        // Calculate dimensions based on fit mode
        function calculateFitDimensions(mediaWidth, mediaHeight, canvasWidth, canvasHeight, fitMode) {
            const mediaAspect = mediaWidth / mediaHeight;
            const canvasAspect = canvasWidth / canvasHeight;
            let drawWidth, drawHeight, drawX, drawY;

            switch (fitMode) {
                case 'cover':
                    // Fill canvas, may crop
                    if (canvasAspect > mediaAspect) {
                        drawWidth = canvasWidth;
                        drawHeight = drawWidth / mediaAspect;
                        drawX = 0;
                        drawY = (canvasHeight - drawHeight) / 2;
                    } else {
                        drawHeight = canvasHeight;
                        drawWidth = drawHeight * mediaAspect;
                        drawX = (canvasWidth - drawWidth) / 2;
                        drawY = 0;
                    }
                    break;

                case 'contain':
                    // Fit all, may letterbox
                    if (canvasAspect > mediaAspect) {
                        drawHeight = canvasHeight;
                        drawWidth = drawHeight * mediaAspect;
                        drawX = (canvasWidth - drawWidth) / 2;
                        drawY = 0;
                    } else {
                        drawWidth = canvasWidth;
                        drawHeight = drawWidth / mediaAspect;
                        drawX = 0;
                        drawY = (canvasHeight - drawHeight) / 2;
                    }
                    break;

                case 'fill':
                    // Stretch to fill
                    drawWidth = canvasWidth;
                    drawHeight = canvasHeight;
                    drawX = 0;
                    drawY = 0;
                    break;

                default:
                    // Default to cover
                    return calculateFitDimensions(mediaWidth, mediaHeight, canvasWidth, canvasHeight, 'cover');
            }

            return { drawWidth, drawHeight, drawX, drawY };
        }

        // RENDER MEDIA PREVIEW
        function renderMediaPreview() {
            if (!stagedMediaFile || !stagedMediaURL) return;

            const ctx = unifiedCanvas.getContext('2d');
            if (!ctx) {
                console.error('[Control] Failed to get 2D context for media preview');
                return;
            }

            // Create IMG or VIDEO element based on type
            if (stagedMediaType === 'image') {
                if (!mediaElement || mediaElement.tagName !== 'IMG') {
                    mediaElement = document.createElement('img');
                }

                mediaElement.onload = () => {
                    console.log('[Control] Image loaded:', stagedMediaFile.name);
                    document.getElementById('staged-name').textContent = 'Image: ' + stagedMediaFile.name;

                    // Start animation loop for image (needed for fit mode changes)
                    if (!window.mediaPreviewAnimating) {
                        window.mediaPreviewAnimating = true;
                        function renderImageFrame() {
                            if (!window.mediaPreviewAnimating) return;

                            if (mediaElement && mediaElement.tagName === 'IMG' && mediaElement.complete) {
                                ctx.fillStyle = '#000';
                                ctx.fillRect(0, 0, unifiedCanvas.width, unifiedCanvas.height);

                                const { drawWidth, drawHeight, drawX, drawY } = calculateFitDimensions(
                                    mediaElement.width,
                                    mediaElement.height,
                                    unifiedCanvas.width,
                                    unifiedCanvas.height,
                                    mediaFitMode
                                );

                                ctx.drawImage(mediaElement, drawX, drawY, drawWidth, drawHeight);
                            }

                            requestAnimationFrame(renderImageFrame);
                        }
                        renderImageFrame();
                    }
                };

                mediaElement.onerror = () => {
                    console.error('[Control] Failed to load image');
                    document.getElementById('staged-name').textContent = 'Error loading image';
                };

                mediaElement.src = stagedMediaURL;

            } else if (stagedMediaType === 'video') {
                if (!mediaElement || mediaElement.tagName !== 'VIDEO') {
                    mediaElement = document.createElement('video');
                    mediaElement.muted = true; // ALWAYS muted - preview is visual only
                    mediaElement.loop = document.getElementById('media-loop').checked;
                }

                mediaElement.onloadedmetadata = () => {
                    console.log('[Control] Video loaded:', stagedMediaFile.name, 'Duration:', mediaElement.duration);
                    document.getElementById('staged-name').textContent = 'Video: ' + stagedMediaFile.name;

                    mediaElement.play().catch(err => {
                        console.warn('[Control] Video autoplay failed:', err);
                    });

                    // Start render loop for video
                    if (!window.mediaPreviewAnimating) {
                        window.mediaPreviewAnimating = true;
                        function renderVideoFrame() {
                            if (!window.mediaPreviewAnimating) return;

                            if (mediaElement && mediaElement.readyState >= 2) {
                                ctx.fillStyle = '#000';
                                ctx.fillRect(0, 0, unifiedCanvas.width, unifiedCanvas.height);

                                const { drawWidth, drawHeight, drawX, drawY } = calculateFitDimensions(
                                    mediaElement.videoWidth,
                                    mediaElement.videoHeight,
                                    unifiedCanvas.width,
                                    unifiedCanvas.height,
                                    mediaFitMode
                                );

                                ctx.drawImage(mediaElement, drawX, drawY, drawWidth, drawHeight);
                            }

                            requestAnimationFrame(renderVideoFrame);
                        }
                        renderVideoFrame();
                    }
                };

                mediaElement.onerror = () => {
                    console.error('[Control] Failed to load video');
                    document.getElementById('staged-name').textContent = 'Error loading video';
                };

                mediaElement.src = stagedMediaURL;
            }
        }

        // GO TO PROGRAM - Media mode
        function goToProgramMedia() {
            console.log('[Control] GO TO PROGRAM: Media file');

            if (!stagedMediaFile || !stagedMediaURL) {
                console.warn('[Control] No media file selected');
                return;
            }

            // Send media file data to main app
            // Note: We can't send File objects via BroadcastChannel, so we send the Object URL
            sendCommand('switchMode', 'media');
            setTimeout(() => {
                sendCommand('mediaLoad', {
                    url: stagedMediaURL,
                    type: stagedMediaType,
                    name: stagedMediaFile.name,
                    loop: document.getElementById('media-loop').checked,
                    fitMode: mediaFitMode
                });
            }, 100);
        }

        // CLEAR MEDIA FILE
        function clearMediaFile() {
            console.log('[Control] Clearing media file...');

            // Revoke object URL to free memory
            if (stagedMediaURL) {
                URL.revokeObjectURL(stagedMediaURL);
                stagedMediaURL = null;
            }

            // Clear media element
            if (mediaElement) {
                if (mediaElement.tagName === 'VIDEO') {
                    mediaElement.pause();
                }
                mediaElement.src = '';
                mediaElement = null;
            }

            stagedMediaFile = null;
            stagedMediaType = null;

            // Update UI
            const fileInput = document.getElementById('media-file-input');
            if (fileInput) {
                fileInput.value = '';
            }

            document.getElementById('media-file-info').style.display = 'none';
            document.getElementById('staged-name').textContent = 'No media selected';

            // Stop animation loop
            window.mediaPreviewAnimating = false;

            // If currently in media preview mode, show placeholder
            if (currentPreviewMode === 'media') {
                const ctx = unifiedCanvas.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, unifiedCanvas.width, unifiedCanvas.height);
                    ctx.fillStyle = '#888';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Select a media file below', unifiedCanvas.width / 2, unifiedCanvas.height / 2);
                }
            }

            console.log('[Control] ‚úì Media file cleared');
        }

        // MILKDROP NAVIGATION
        function stageMilkdropNav(direction) {
            if (direction === 'next') {
                stagedMilkdropIndex = (stagedMilkdropIndex + 1) % milkdropPresetList.length;
            } else {
                stagedMilkdropIndex--;
                if (stagedMilkdropIndex < 0) stagedMilkdropIndex = milkdropPresetList.length - 1;
            }

            // Reload preview with new preset
            if (currentPreviewMode === 'milkdrop' && unifiedMilkdropVisualizer) {
                const allPresets = butterchurnPresets.getPresets();
                const presetKey = milkdropPresetList[stagedMilkdropIndex];
                const preset = allPresets[presetKey];

                if (preset) {
                    unifiedMilkdropVisualizer.loadPreset(preset, 0);
                    document.getElementById('staged-name').textContent = presetKey;
                    console.log('[Control] ‚úì Loaded preset:', presetKey);
                }
            }
        }

        // THREE.JS NAVIGATION
        function stageThreeJSNav(direction) {
            if (direction === 'next') {
                stagedThreeJSIndex = (stagedThreeJSIndex + 1) % threejsPresetList.length;
            } else {
                stagedThreeJSIndex--;
                if (stagedThreeJSIndex < 0) stagedThreeJSIndex = threejsPresetList.length - 1;
            }

            // Update preview if in threejs mode
            previewThreeJSPreset(stagedThreeJSIndex);
        }

        // THREE.JS PRESET PREVIEW
        async function previewThreeJSPreset(index) {
            stagedThreeJSIndex = index;

            // Update button visual states
            for (let i = 0; i < 3; i++) {
                const btn = document.getElementById(`threejs-preset-${i}`);
                if (btn) {
                    if (i === index) {
                        btn.style.background = '#0066FF';
                        btn.style.borderColor = '#0088FF';
                    } else {
                        btn.style.background = '#2a2a2a';
                        btn.style.borderColor = '#3a3a3a';
                    }
                }
            }

            // Update staged name
            const presetNames = ['Geometric Shapes', 'Particles Field', 'Tunnel Infinity'];
            document.getElementById('staged-name').textContent = presetNames[index];

            // If currently in threejs preview mode, load the preset on-demand
            if (currentPreviewMode === 'threejs' && unifiedThreeJSRenderer) {
                const presetKey = threejsPresetList[index];
                // Load fresh preset from disk
                const loaded = await loadThreeJSPreset(presetKey, true);
                if (loaded) {
                    unifiedThreeJSRenderer.loadPreset(presetKey);
                    console.log('[Control] ‚úì Loaded fresh Three.js preset:', presetKey);
                }
            } else {
                console.log('[Control] Staged Three.js preset:', threejsPresetList[index]);
            }
        }

        // BUILT-IN SCENE PREVIEW
        function previewBuiltinScene(sceneIndex) {
            stagedBuiltinScene = sceneIndex;

            // Update button visual states
            for (let i = 0; i < 4; i++) {
                const btn = document.getElementById(`scene-${i}`);
                if (btn) {
                    if (i === sceneIndex) {
                        btn.style.background = '#0066FF';
                        btn.style.borderColor = '#0088FF';
                    } else {
                        btn.style.background = '#2a2a2a';
                        btn.style.borderColor = '#3a3a3a';
                    }
                }
            }

            // If currently in builtin preview mode, update the preview immediately
            if (currentPreviewMode === 'builtin') {
                // Reinitialize if renderer mode changed
                const needsReinit = unifiedPreviewRenderer && unifiedPreviewRenderer.mode !== currentRendererMode;
                if (needsReinit) {
                    console.log('[Control] Renderer mode changed, reinitializing...');
                    unifiedPreviewRenderer.stop();
                    unifiedPreviewRenderer = new VisualRenderer('unified-preview-canvas');
                    unifiedPreviewRenderer.initialize(currentRendererMode);
                    unifiedSceneManager = new SceneManager(unifiedPreviewRenderer);
                }

                // Switch scene and update display
                if (unifiedSceneManager) {
                    unifiedSceneManager.switchScene(sceneIndex);
                    const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
                    document.getElementById('staged-name').textContent = sceneNames[sceneIndex];

                    // CRITICAL: Make sure renderer is running after scene switch
                    if (!unifiedPreviewRenderer.isRunning) {
                        unifiedPreviewRenderer.start();
                    }

                    console.log('[Control] ‚úì Previewing scene:', sceneNames[sceneIndex]);
                }
            } else {
                // Just update the staged value, will load when user switches to builtin tab
                const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
                console.log('[Control] Staged scene:', sceneNames[sceneIndex]);
            }
        }

        // OLD MILKDROP PREVIEW FUNCTION - REPLACED BY UNIFIED SYSTEM
        function previewMilkdropPreset(index) {
            try {
                if (!milkdropPresetList || milkdropPresetList.length === 0) {
                    console.warn('[Control] No milkdrop preset list available');
                    return;
                }

                // Check if butterchurn is loaded
                if (typeof butterchurn === 'undefined' || typeof butterchurnPresets === 'undefined') {
                    console.error('[Control] Butterchurn library not loaded - skipping preview');
                    return;
                }

                stagedMilkdropIndex = index;

                // Initialize Milkdrop if not exists
                if (!milkdropPreviewVisualizer) {
                    console.log('[Control] Creating Milkdrop preview visualizer...');
                    const canvas = document.getElementById('milkdrop-preview-canvas');
                    canvas.width = 640;
                    canvas.height = 360;

                    // Create AudioContext for butterchurn
                    milkdropPreviewAudioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Try both API variations (butterchurn vs butterchurn.default)
                    const butterchurnAPI = butterchurn.createVisualizer ? butterchurn : (butterchurn.default || butterchurn);

                    if (!butterchurnAPI.createVisualizer) {
                        console.error('[Control] Butterchurn API not available - createVisualizer not found');
                        console.log('[Control] Available butterchurn properties:', Object.keys(butterchurn));
                        return;
                    }

                    // Create butterchurn instance
                    milkdropPreviewVisualizer = butterchurnAPI.createVisualizer(milkdropPreviewAudioContext, canvas, {
                        width: 640,
                        height: 360,
                        pixelRatio: 1,
                        meshWidth: 32,
                        meshHeight: 24
                    });

                    console.log('[Control] ‚úì Milkdrop preview visualizer created');
                }

                // Show preview container
                document.getElementById('milkdrop-preview-container').style.display = 'block';

                // Load preset
                const allPresets = butterchurnPresets.getPresets();
                const presetKey = milkdropPresetList[index];
                const preset = allPresets[presetKey];

                if (!preset) {
                    console.error('[Control] Preset not found:', presetKey);
                    return;
                }

                milkdropPreviewVisualizer.loadPreset(preset, 0); // 0 = no blend transition
                console.log('[Control] ‚úì Previewing Milkdrop preset:', presetKey);

                // Start render loop if not already running
                if (!window.milkdropPreviewAnimating) {
                    window.milkdropPreviewAnimating = true;
                    function animateMilkdropPreview() {
                        if (milkdropPreviewVisualizer) {
                            try {
                                milkdropPreviewVisualizer.render();
                                requestAnimationFrame(animateMilkdropPreview);
                            } catch (err) {
                                console.error('[Control] Milkdrop render error:', err);
                                window.milkdropPreviewAnimating = false;
                            }
                        }
                    }
                    animateMilkdropPreview();
                }
            } catch (error) {
                console.error('[Control] Failed to preview Milkdrop preset:', error);
                console.error('[Control] Error stack:', error.stack);
                // Don't show alert - just log error to avoid blocking UI
            }
        }

        // MIDI for optional external control
        let midiAccess = null;
        let midiOutput = null;

        // Send command to main tab via BroadcastChannel
        function sendCommand(command, data) {
            const message = { command, data };
            controlChannel.postMessage(message);
            console.log('[Control] Sent:', message);
        }

        // Receive state updates from main tab
        controlChannel.onmessage = (event) => {
            const { type, data } = event.data;

            switch (type) {
                case 'stateUpdate':
                    updateState(data);
                    break;
                case 'presetList':
                    displayPresets(data);
                    break;
            }
        };

        function updateState(state) {
            // Update connection status
            document.getElementById('connection-status').classList.add('connected');

            // Update BPM and position
            if (state.bpm !== undefined) {
                document.getElementById('current-bpm').textContent = state.bpm;
            }
            if (state.position !== undefined) {
                document.getElementById('current-position').textContent = state.position;
            }

            // Update audio device selection
            if (state.audioDeviceId !== undefined) {
                const audioSelect = document.getElementById('audio-device-select');
                audioSelect.value = state.audioDeviceId;
            }

            // Update EQ bars
            if (state.frequency !== undefined) {
                const bass = Math.min(100, Math.round((state.frequency.bass || 0) * 100));
                const mid = Math.min(100, Math.round((state.frequency.mid || 0) * 100));
                const high = Math.min(100, Math.round((state.frequency.high || 0) * 100));

                document.getElementById('bass-bar').style.height = `${bass}%`;
                document.getElementById('mid-bar').style.height = `${mid}%`;
                document.getElementById('high-bar').style.height = `${high}%`;
            }

            // Update SPP indicator
            if (state.sppActive === true) {
                const sppIndicator = document.getElementById('spp-indicator');
                sppIndicator.classList.add('spp');
                // Remove after animation completes
                setTimeout(() => {
                    sppIndicator.classList.remove('spp');
                }, 300);
            }

            // Update visual audio source - ALWAYS from main app state, NEVER from saved settings
            if (state.visualAudioSource !== undefined) {
                const dropdown = document.getElementById('milkdrop-audio-source');
                dropdown.value = state.visualAudioSource;
                // Removed spam log - broadcasts every 100ms

                // Show/hide MIDI options based on source
                const midiOptions = document.getElementById('midi-synth-options');
                midiOptions.style.display = state.visualAudioSource === 'midi' ? 'block' : 'none';
            }

            // Update MIDI synth settings
            if (state.midiSynthChannel !== undefined) {
                document.getElementById('midi-synth-channel').value = state.midiSynthChannel;
            }
            if (state.midiSynthAudible !== undefined) {
                document.getElementById('midi-synth-audible').checked = state.midiSynthAudible === 'true';
            }

            // Update current mode display and track program mode
            if (state.mode) {
                currentProgramMode = state.mode; // Track current program mode
                const modeNames = { builtin: 'Built-in', threejs: 'Three.js', milkdrop: 'Milkdrop', video: 'Video' };
                document.getElementById('current-mode-display').textContent = modeNames[state.mode] || state.mode;

                // Show/hide scene display based on mode
                const sceneDisplay = document.getElementById('program-scene-display');
                if (sceneDisplay) {
                    if (state.mode === 'builtin' && state.scene !== undefined) {
                        currentProgramScene = state.scene; // Track current scene
                        const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
                        const sceneNameElement = document.getElementById('program-scene-name');
                        if (sceneNameElement) {
                            sceneNameElement.textContent = sceneNames[state.scene] || state.scene;
                        }
                        sceneDisplay.style.display = '';
                    } else {
                        sceneDisplay.style.display = 'none';
                    }
                }

                // Update Built-in section program display
                const builtinProgramDisplay = document.getElementById('program-builtin-display');
                if (builtinProgramDisplay) {
                    if (state.mode === 'builtin' && state.scene !== undefined) {
                        const sceneNames = ['1 - Tunnel', '2 - Particles', '3 - Kaleidoscope', '4 - Waveform'];
                        const builtinNameElement = document.getElementById('program-builtin-name');
                        if (builtinNameElement) {
                            builtinNameElement.textContent = sceneNames[state.scene];
                        }
                        builtinProgramDisplay.style.display = '';
                    } else {
                        builtinProgramDisplay.style.display = 'none';
                    }
                }
            }

            // DON'T sync scene buttons from program - they represent what's staged, not what's on program
            // Scene button styling is controlled by previewBuiltinScene() function

            // Update program preset name (what's on main display)
            if (state.presetName && state.mode === 'milkdrop') {
                const programPresetDisplay = document.getElementById('program-preset-display');
                const programPresetName = document.getElementById('program-preset-name');
                if (programPresetDisplay && programPresetName) {
                    programPresetName.textContent = state.presetName;
                    programPresetDisplay.style.display = '';
                }
            } else {
                const programPresetDisplay = document.getElementById('program-preset-display');
                if (programPresetDisplay) {
                    programPresetDisplay.style.display = 'none';
                }
            }

            // Update audio source display
            if (state.audioSourceDisplay) {
                const audioSourceElement = document.getElementById('current-audio-source');
                if (audioSourceElement) {
                    audioSourceElement.textContent = state.audioSourceDisplay;
                }
            }

            // Update MIDI input device
            if (state.midiInputId !== undefined) {
                const midiSelect = document.getElementById('midi-input-select');
                if (midiSelect && midiSelect.querySelector(`option[value="${state.midiInputId}"]`)) {
                    midiSelect.value = state.midiInputId;
                }
            }

            // Update SysEx setting
            if (state.enableSysEx !== undefined) {
                const sysexElement = document.getElementById('sysex-enable');
                if (sysexElement) {
                    sysexElement.value = state.enableSysEx;
                }
            }

            // Update program renderer display (what's actually on main display)
            if (state.renderer !== undefined && state.mode === 'builtin') {
                currentProgramRenderer = state.renderer; // Track current program renderer
                const rendererNames = { webgl: 'WebGL', canvas2d: 'Canvas 2D' };
                const rendererNameElement = document.getElementById('program-renderer-name');
                const rendererDisplayElement = document.getElementById('program-renderer-display');
                if (rendererNameElement && rendererDisplayElement) {
                    rendererNameElement.textContent = rendererNames[state.renderer] || state.renderer;
                    rendererDisplayElement.style.display = '';
                }

                // Only initialize staged renderer dropdown once on first state update
                if (!window.rendererInitialized) {
                    currentRendererMode = state.renderer;
                    const rendererSelect = document.getElementById('renderer-select');
                    if (rendererSelect) {
                        rendererSelect.value = state.renderer;
                    }
                    window.rendererInitialized = true;
                }
            } else {
                const rendererDisplay = document.getElementById('program-renderer-display');
                if (rendererDisplay) {
                    rendererDisplay.style.display = 'none';
                }
            }

            // Update OSC server
            if (state.oscServer !== undefined) {
                const oscServerElement = document.getElementById('osc-server');
                if (oscServerElement) {
                    oscServerElement.value = state.oscServer;
                }
            }

            // Update video device selection
            if (state.videoDeviceId !== undefined) {
                const videoSelect = document.getElementById('video-device-select');
                if (videoSelect && videoSelect.querySelector(`option[value="${state.videoDeviceId}"]`)) {
                    videoSelect.value = state.videoDeviceId;
                }
            }

            // Update video audio reactive toggle
            if (state.videoAudioReactive !== undefined) {
                const videoAudioReactiveElement = document.getElementById('video-audio-reactive');
                if (videoAudioReactiveElement) {
                    videoAudioReactiveElement.checked = state.videoAudioReactive === 'true';
                }
            }

            // Update video beat reactive toggle
            if (state.videoBeatReactive !== undefined) {
                const videoBeatReactiveElement = document.getElementById('video-beat-reactive');
                if (videoBeatReactiveElement) {
                    videoBeatReactiveElement.checked = state.videoBeatReactive === 'true';
                }
            }

            // Update display settings checkboxes
            if (state.showStatusBar !== undefined) {
                const showStatusBarElement = document.getElementById('show-status-bar');
                if (showStatusBarElement) {
                    showStatusBarElement.checked = state.showStatusBar === 'true';
                }
            }
            if (state.showControlPanel !== undefined) {
                const showControlPanelElement = document.getElementById('show-control-panel');
                if (showControlPanelElement) {
                    showControlPanelElement.checked = state.showControlPanel === 'true';
                }
            }
            if (state.isFullscreen !== undefined) {
                const useFullscreenElement = document.getElementById('use-fullscreen');
                if (useFullscreenElement) {
                    useFullscreenElement.checked = state.isFullscreen === 'true';
                }
            }
        }


        // Load preset list from main app (not local config)
        // This is now handled by 'requestState' which triggers 'presetList' broadcast
        async function loadPresets() {
            console.log('[Control] Preset list will be loaded from main app via BroadcastChannel');
            // No local loading - main app is source of truth
        }

        function displayPresets(presets) {
            if (!presets || presets.length === 0) {
                return;
            }

            // Store preset list for staging
            milkdropPresetList = presets;

            const list = document.getElementById('preset-list');
            list.innerHTML = '';

            presets.forEach((preset, index) => {
                const item = document.createElement('div');
                item.className = 'preset-item';
                item.textContent = `${index}: ${preset}`;
                item.dataset.index = index;
                item.dataset.preset = preset;
                list.appendChild(item);
            });
        }

        // Event delegation for preset clicks - LOAD preset into unified preview
        document.getElementById('preset-list').addEventListener('click', (e) => {
            const item = e.target.closest('.preset-item');
            if (item) {
                const index = parseInt(item.dataset.index);

                // Update active state
                document.querySelectorAll('.preset-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');

                // Update staged index
                stagedMilkdropIndex = index;

                // If currently in milkdrop preview mode, load the preset immediately
                if (currentPreviewMode === 'milkdrop' && unifiedMilkdropVisualizer) {
                    const allPresets = butterchurnPresets.getPresets();
                    const presetKey = milkdropPresetList[index];
                    const preset = allPresets[presetKey];

                    if (preset) {
                        unifiedMilkdropVisualizer.loadPreset(preset, 0);
                        document.getElementById('staged-name').textContent = presetKey;
                        console.log('[Control] ‚úì Loaded preset:', presetKey);
                    }
                } else {
                    // Just stage it - will load when user switches to milkdrop tab
                    console.log('[Control] Preset staged - switch to Milkdrop tab to preview');
                }
            }
        });

        // Audio device selection
        document.getElementById('audio-device-select').addEventListener('change', (e) => {
            sendCommand('audioDeviceSelect', e.target.value);
        });

        // Milkdrop audio source selection
        document.getElementById('milkdrop-audio-source').addEventListener('change', (e) => {
            const source = e.target.value;
            sendCommand('milkdropAudioSource', source);

            // Show/hide MIDI synth options
            const midiOptions = document.getElementById('midi-synth-options');
            midiOptions.style.display = source === 'midi' ? 'block' : 'none';
        });

        // MIDI synth channel
        document.getElementById('midi-synth-channel').addEventListener('change', (e) => {
            sendCommand('midiSynthChannel', e.target.value);
        });

        // MIDI synth audible toggle
        document.getElementById('midi-synth-audible').addEventListener('change', (e) => {
            sendCommand('midiSynthAudible', e.target.checked ? 'true' : 'false');
        });

        // MIDI input device selection
        document.getElementById('midi-input-select').addEventListener('change', (e) => {
            sendCommand('midiInputSelect', e.target.value);
        });

        // SysEx enable
        document.getElementById('sysex-enable').addEventListener('change', (e) => {
            sendCommand('sysexEnable', e.target.value);
        });

        // Renderer selection - STAGE ONLY (don't send to program immediately)
        document.getElementById('renderer-select').addEventListener('change', (e) => {
            const newMode = e.target.value;
            currentRendererMode = newMode;
            console.log('[Control] Renderer changed to:', newMode);

            // Reinitialize unified preview if builtin mode is active
            if (currentPreviewMode === 'builtin' && unifiedPreviewRenderer) {
                console.log('[Control] Reinitializing preview with new renderer...');
                unifiedPreviewRenderer.stop();
                unifiedPreviewRenderer = new VisualRenderer('unified-preview-canvas');
                unifiedPreviewRenderer.initialize(currentRendererMode);
                unifiedSceneManager = new SceneManager(unifiedPreviewRenderer);
                unifiedSceneManager.switchScene(stagedBuiltinScene);
                unifiedPreviewRenderer.start();
                console.log('[Control] ‚úì Preview reinitialized');
            }

            // DON'T send to main app - only send when user clicks GO TO PROGRAM
        });

        // Display settings - Status Bar
        document.getElementById('show-status-bar').addEventListener('change', (e) => {
            sendCommand('toggleStatusBar', e.target.checked ? 'true' : 'false');
        });

        // Display settings - Control Panel
        document.getElementById('show-control-panel').addEventListener('change', (e) => {
            sendCommand('toggleControlPanel', e.target.checked ? 'true' : 'false');
        });

        // Display settings - Fullscreen (read-only status display)
        // Fullscreen can only be triggered by user gesture in main window (use F11)
        // Checkbox is disabled and only shows current fullscreen state

        // OSC server
        document.getElementById('osc-server').addEventListener('change', (e) => {
            sendCommand('oscServer', e.target.value);
        });

        // Video device selection - show preview first
        document.getElementById('video-device-select').addEventListener('change', async (e) => {
            const deviceId = e.target.value;
            stagedVideoDeviceId = deviceId;

            if (!deviceId) {
                console.log('[Control] No camera selected');
                // If currently in video preview mode, clear it
                if (currentPreviewMode === 'video') {
                    const ctx = unifiedCanvas.getContext('2d');
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, unifiedCanvas.width, unifiedCanvas.height);
                    ctx.fillStyle = '#888';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Select a camera below', unifiedCanvas.width / 2, unifiedCanvas.height / 2);
                    document.getElementById('staged-name').textContent = 'No camera selected';

                    // Release renderer
                    if (unifiedPreviewRenderer) {
                        unifiedPreviewRenderer.release();
                        unifiedPreviewRenderer = null;
                    }
                }
                return;
            }

            console.log('[Control] Camera selected:', deviceId);

            // If currently in video preview mode, reload preview with new camera
            if (currentPreviewMode === 'video') {
                // Release old camera
                if (unifiedPreviewRenderer) {
                    console.log('[Control] Releasing previous camera...');
                    unifiedPreviewRenderer.release();
                    await new Promise(resolve => setTimeout(resolve, 300));
                    unifiedPreviewRenderer = null;
                }

                // Load new camera
                await initVideoPreview();
            } else {
                // Just staged - will load when user switches to video tab
                console.log('[Control] Camera staged - switch to Video tab to preview');
            }
        });

        // Video audio reactive toggle
        document.getElementById('video-audio-reactive').addEventListener('change', (e) => {
            sendCommand('videoAudioReactive', e.target.checked ? 'true' : 'false');
        });

        // Video beat reactive toggle
        document.getElementById('video-beat-reactive').addEventListener('change', (e) => {
            sendCommand('videoBeatReactive', e.target.checked ? 'true' : 'false');
        });

        // Drag-and-drop for media files
        const dropZone = document.getElementById('media-drop-zone');
        const fileInput = document.getElementById('media-file-input');

        // Click to browse
        dropZone.addEventListener('click', () => {
            fileInput.click();
        });

        // Drag over
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#0066FF';
            dropZone.style.background = '#0a1a2a';
        });

        // Drag leave
        dropZone.addEventListener('dragleave', () => {
            dropZone.style.borderColor = '#2a2a2a';
            dropZone.style.background = '#0a0a0a';
        });

        // Drop
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#2a2a2a';
            dropZone.style.background = '#0a0a0a';

            const file = e.dataTransfer.files[0];
            if (file) {
                handleMediaFile(file);
            }
        });

        // File input change (from click to browse)
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleMediaFile(file);
            }
        });

        // Unified media file handler
        function handleMediaFile(file) {
            console.log('[Control] Media file selected:', file.name, 'Type:', file.type, 'Size:', file.size);

            // Determine media type
            if (file.type.startsWith('image/')) {
                stagedMediaType = 'image';
            } else if (file.type.startsWith('video/')) {
                stagedMediaType = 'video';
            } else {
                alert('Unsupported file type. Please select an image or video file.');
                fileInput.value = '';
                return;
            }

            // Revoke previous object URL if exists
            if (stagedMediaURL) {
                URL.revokeObjectURL(stagedMediaURL);
            }

            // Create object URL for preview
            stagedMediaFile = file;
            stagedMediaURL = URL.createObjectURL(file);

            // Update file info display
            document.getElementById('media-file-name').textContent = file.name;
            document.getElementById('media-file-type').textContent = `Type: ${file.type}`;
            document.getElementById('media-file-size').textContent = `Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`;
            document.getElementById('media-file-info').style.display = 'block';

            // If currently in media preview mode, reload preview
            if (currentPreviewMode === 'media') {
                renderMediaPreview();
            } else {
                console.log('[Control] Media file staged - switch to Media tab to preview');
            }
        }

        // Media fit mode selector
        document.getElementById('media-fit-mode').addEventListener('change', (e) => {
            mediaFitMode = e.target.value;
            console.log('[Control] Media fit mode STAGED:', mediaFitMode);

            // DON'T send to program - only stage it for preview
            // It will be sent when user clicks "GO TO PROGRAM"

            // If currently in media preview mode and media is loaded, re-render
            if (currentPreviewMode === 'media' && mediaElement) {
                if (stagedMediaType === 'image') {
                    // Re-render image
                    const ctx = unifiedCanvas.getContext('2d');
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, unifiedCanvas.width, unifiedCanvas.height);

                    const { drawWidth, drawHeight, drawX, drawY } = calculateFitDimensions(
                        mediaElement.width,
                        mediaElement.height,
                        unifiedCanvas.width,
                        unifiedCanvas.height,
                        mediaFitMode
                    );

                    ctx.drawImage(mediaElement, drawX, drawY, drawWidth, drawHeight);
                }
                // Video will update automatically in render loop
            }
        });

        // Media loop toggle
        document.getElementById('media-loop').addEventListener('change', (e) => {
            if (mediaElement && mediaElement.tagName === 'VIDEO') {
                mediaElement.loop = e.target.checked;
                console.log('[Control] Video loop:', e.target.checked);
            }
        });

        // Media audio reactive toggle
        document.getElementById('media-audio-reactive').addEventListener('change', (e) => {
            console.log('[Control] Media audio reactive:', e.target.checked);
            // Send to program in real-time
            sendCommand('mediaAudioReactive', e.target.checked ? 'true' : 'false');
        });

        // Media beat reactive toggle
        document.getElementById('media-beat-reactive').addEventListener('change', (e) => {
            console.log('[Control] Media beat reactive:', e.target.checked);
            // Send to program in real-time
            sendCommand('mediaBeatReactive', e.target.checked ? 'true' : 'false');
        });

        // Populate audio devices
        // NOTE: Devices need permission granted first to show proper labels
        // Permission should already be granted by index.html on load
        async function loadAudioDevices() {
            const select = document.getElementById('audio-device-select');
            const warning = document.getElementById('audio-perm-warning');
            select.innerHTML = '<option value="none">No Audio Input</option>';

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');

                // Check if we have permission (devices will have labels)
                const hasPermission = audioInputs.length > 0 && audioInputs[0].label !== '';

                if (!hasPermission && audioInputs.length > 0) {
                    // Devices exist but no labels = permission not granted
                    console.log('[Control] Audio permission not granted - device labels are empty');
                    console.log('[Control] ‚ö†Ô∏è Click PERMISSIONS button in index.html to grant audio access');
                    warning.style.display = 'inline';
                    return;
                }

                // Hide warning - permission granted
                warning.style.display = 'none';

                if (audioInputs.length === 0) {
                    console.log('[Control] No audio input devices found');
                    select.innerHTML = '<option value="none">No audio devices found</option>';
                    return;
                }

                // We have permission - show device names
                audioInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label;
                    select.appendChild(option);
                });

                console.log('[Control] Found', audioInputs.length, 'audio devices with labels');
            } catch (error) {
                console.error('[Control] Failed to enumerate audio devices:', error.message);
                select.innerHTML = '<option value="none">Error loading audio devices</option>';
            }
        }

        // Populate MIDI devices
        // NOTE: MIDI is OPTIONAL - browser may not support it or it may require HTTPS
        async function loadMIDIDevices() {
            const select = document.getElementById('midi-input-select');
            const warning = document.getElementById('midi-perm-warning');

            try {
                // Only request if not already available (won't trigger new prompt if granted)
                const access = await navigator.requestMIDIAccess();
                select.innerHTML = '';

                // Hide warning - MIDI is available
                warning.style.display = 'none';

                const inputs = Array.from(access.inputs.values());

                if (inputs.length === 0) {
                    select.innerHTML = '<option value="">No MIDI devices found</option>';
                    console.log('[Control] MIDI access granted but no devices connected');
                    return;
                }

                inputs.forEach(input => {
                    const option = document.createElement('option');
                    option.value = input.id;
                    option.textContent = input.name;
                    select.appendChild(option);
                });

                console.log('[Control] Found', inputs.length, 'MIDI devices');
            } catch (error) {
                // MIDI not available - this is OPTIONAL, so just hide warning and show message
                console.log('[Control] MIDI not available:', error.message);
                console.log('[Control] This is optional - browser may not support MIDI or requires HTTPS');

                // Hide warning - MIDI is optional, not required
                warning.style.display = 'none';

                select.innerHTML = '<option value="">MIDI not available (browser may not support it)</option>';
            }
        }

        // Populate video devices
        async function loadVideoDevices() {
            const select = document.getElementById('video-device-select');
            const warning = document.getElementById('video-perm-warning');
            select.innerHTML = '<option value="">No camera selected</option>';

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoInputs = devices.filter(device => device.kind === 'videoinput');

                // Check if we have permission (devices will have labels)
                const hasPermission = videoInputs.length > 0 && videoInputs[0].label !== '';

                if (!hasPermission && videoInputs.length > 0) {
                    // Devices exist but no labels = permission not granted
                    console.log('[Control] Video permission not granted - device labels are empty');
                    console.log('[Control] ‚ö†Ô∏è Click PERMISSIONS button in index.html to grant camera access');
                    warning.style.display = 'inline';
                    return;
                }

                // Hide warning - permission granted
                warning.style.display = 'none';

                videoInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label;
                    select.appendChild(option);
                });

                console.log('[Control] Found', videoInputs.length, 'video devices with labels');
            } catch (error) {
                console.error('[Control] Failed to enumerate video devices:', error.message);
            }
        }

        // Dynamic Three.js preset loader
        // Preset info mapping
        function getThreeJSPresetInfo(presetName) {
            const presetMap = {
                'geometric': { file: 'presets/threejs/GeometricShapes.js', className: 'GeometricShapesPreset' },
                'particles': { file: 'presets/threejs/Particles.js', className: 'ParticlesPreset' },
                'tunnel': { file: 'presets/threejs/Tunnel.js', className: 'TunnelPreset' }
            };
            return presetMap[presetName];
        }

        async function loadThreeJSPreset(presetName, cacheBust = true) {
            const presetInfo = getThreeJSPresetInfo(presetName);
            if (!presetInfo) {
                console.error(`[Control] Unknown preset: ${presetName}`);
                return false;
            }

            try {
                console.log(`[Control] Loading Three.js preset on-demand: ${presetName}${cacheBust ? ' (fresh)' : ''}`);
                await loadScript(presetInfo.file, cacheBust);

                if (typeof window[presetInfo.className] !== 'undefined') {
                    unifiedThreeJSRenderer.registerPreset(presetName, window[presetInfo.className]);
                    console.log(`[Control] ‚úì Loaded Three.js preset: ${presetName}`);
                    return true;
                } else {
                    console.warn(`[Control] ‚úó Preset class ${presetInfo.className} not found`);
                    return false;
                }
            } catch (error) {
                console.error(`[Control] Failed to load preset ${presetName}:`, error);
                return false;
            }
        }

        async function loadThreeJSPresets() {
            const presetNames = ['geometric', 'particles', 'tunnel'];
            for (const presetName of presetNames) {
                await loadThreeJSPreset(presetName, false);
            }
        }

        function loadScript(src, cacheBust = false) {
            return new Promise((resolve, reject) => {
                // Remove old script with same src if it exists
                const oldScripts = document.querySelectorAll(`script[data-preset-src="${src}"]`);
                oldScripts.forEach(s => s.remove());

                const script = document.createElement('script');
                script.setAttribute('data-preset-src', src);

                // Add cache-busting timestamp to force reload
                if (cacheBust) {
                    script.src = `${src}?t=${Date.now()}`;
                } else {
                    script.src = src;
                }

                script.onload = () => resolve();
                script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
                document.head.appendChild(script);
            });
        }

        // Force dropdown to default to "microphone" on load
        // Main app will NEVER auto-start MIDI synth, so this is always correct initially
        document.getElementById('milkdrop-audio-source').value = 'microphone';
        document.getElementById('midi-synth-options').style.display = 'none';
        console.log('[Control] Defaulted to Audio Input Device');

        // CRITICAL: Force main app to microphone mode on control.html load
        // This ensures MIDI synth is never auto-started
        console.log('[Control] Forcing Visual Reactive Input to microphone...');
        sendCommand('milkdropAudioSource', 'microphone');

        // Initialize unified preview system
        console.log('[Control] Initializing unified preview system...');
        unifiedCanvas = document.getElementById('unified-preview-canvas');

        // Start with built-in preview by default
        setTimeout(() => {
            switchPreviewMode('builtin');
        }, 100);

        // Initialize
        loadPresets();
        loadAudioDevices();
        loadMIDIDevices();
        loadVideoDevices();

        // Request full state after a short delay (allows commands to be processed first)
        setTimeout(() => {
            console.log('[Control] Requesting state from main app...');
            sendCommand('requestState');
        }, 200);
    </script>
</body>
</html>
